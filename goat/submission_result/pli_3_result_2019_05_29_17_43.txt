============================================
vis/aluo1.out
17:43:46_Wednesday_29_May_2019
============================================
COMP90045 project - Test of semantic analysis and code generation
User:  aluo1

--- Makefile found ---
--- Running Makefile ---
ghc Goat.hs -o Goat
[ 1 of 12] Compiling GoatAST          ( GoatAST.hs, GoatAST.o )
[ 2 of 12] Compiling GoatConstant     ( GoatConstant.hs, GoatConstant.o )
[ 3 of 12] Compiling GoatExit         ( GoatExit.hs, GoatExit.o )
[ 4 of 12] Compiling GoatParser       ( GoatParser.hs, GoatParser.o )
[ 5 of 12] Compiling SymbolTable      ( SymbolTable.hs, SymbolTable.o )
[ 6 of 12] Compiling Util             ( Util.hs, Util.o )
[ 7 of 12] Compiling GoatPrettyPrint  ( GoatPrettyPrint.hs, GoatPrettyPrint.o )
[ 8 of 12] Compiling AnalyzerUtil     ( AnalyzerUtil.hs, AnalyzerUtil.o )
[ 9 of 12] Compiling MainAnalyzer     ( MainAnalyzer.hs, MainAnalyzer.o )
[10 of 12] Compiling Analyzer         ( Analyzer.hs, Analyzer.o )
[11 of 12] Compiling CodeGenerator    ( CodeGenerator.hs, CodeGenerator.o )
[12 of 12] Compiling Main             ( Goat.hs, Goat.o )
Linking Goat ...

--- Succeeded to create a file called Goat ---

PLEASE NOTE: These cases are very basic and are not intended to be
comprehensive. Passing these does not guarantee a correct compiler!

--- Running basic test of each milestone ---
Milestone 1: Expressions and write statement
PASS
Milestone 2: Read and assignment statements; int-to-float
PASS
Milestone 3: If and while statements
PASS
Milestone 4: Procedure arguments and calls (by-value only)
PASS
Milestone 5: By-reference arguments
PASS
Milestone 6: Arrays and matrices
PASS

--- Running public (visible) tests ---
vis/*.gt)
arrayprod:          PASS
asg:                PASS
assoc:              PASS
bell:               PASS
gcd:                PASS
hail:               PASS
hello:              PASS
io:                 PASS
matrixmul:          PASS
power:              PASS
q45:                PASS
q46:                PASS
q48:                PASS
q49:                PASS
q50:                PASS
q51:                PASS
sort:               PASS
stddev:             PASS
18/18 cases passed

--- Running peer-contributed tests ---
(peer/*.gt)
aadornobenit:       PASS
alanu:              PASS
aluo1:              PASS
apurushotha:        PASS
austinl.bad:        PASS:
Compiler output:
bgooding:           PASS
chenqinz:           PASS
chunyaow:           PASS
codya:              PASS
dbarrell:           PASS
dstern:             PASS
farrugiam:          PASS
glaw:               PASS
guoenj:             PASS
haohail.runbad:     PASS:
Fatal error:
Output:
BAAAAAAAAAAAAAAAAAAAAAAAAAA!
Welcome to quantum bogo sort, for additional info please visit: http://wiki.c2.com/?QuantumBogoSort
disclaimer, this algorithim may destory your universe, the author of this code will not take any responsibilities for the annhiliation of your world.
Please press 1 to continue, press 2 to terminate
Please enter a random number
Please enter more numbers
Please enter more numbers
Please enter more numbers
Please enter more number
Begin Sorting
Error:
at instruction 77, pc 79: address @9 is not in any current stack frame
harald:             PASS
jiaxingt:           PASS
liangy6:            PASS
linghanz1:          PASS
liyaoz:             PASS
lpendock:           PASS
mchan:              PASS
mingdam:            PASS
mingyangz:          PASS
minjianc:           PASS
peiyuh:             PASS
raymonds1:          PASS
shijiel2:           PASS
shizhec:            PASS
shumaox:            PASS
stevent2:           PASS
weizhix:            PASS
weizhuoz:           PASS
wenqingx:           PASS
wentaol4:           PASS
wleong3:            PASS
yigew3:             PASS
yiqunw1.bad:        PASS:
Compiler output:
yixiong:            PASS
yiyue:              PASS
yuankail:           PASS
zeleic:             PASS
zeyuh3:             PASS
zhengjiex1:         PASS
zhet1:              PASS
zijunc3:            PASS
46/46 cases passed

--- End of public testing for aluo1 ---

============================================
src/SymbolTable.hs
17:43:38_Wednesday_29_May_2019
============================================
module SymbolTable where

import           Data.Map
import qualified Data.Map.Strict as M
import           GoatAST

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the symbol table-related information of the Goat program.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

type ProgramMap = M.Map Identifier ProcedureTable

type ParameterMap = M.Map Identifier (Int, Parameter)

type VariableMap = M.Map Identifier VariableDeclaration

type StackMap = M.Map Identifier Int

data ProcedureTable = ProcedureTable { parameterMap   :: ParameterMap
                                     , variableMap    :: VariableMap
                                     , statementTable :: [StatementTable]
                                     } deriving (Show, Eq)

data StatementTable = WriteTable     { writeExprTable    :: ExpressionTable }
                    | ReadTable      { readExprTable     :: ExpressionTable }
                    | AssignTable    { assignVarTable  :: ExpressionTable
                                     , assignExprTable :: ExpressionTable}
                    | IfTable        { ifExprTable  :: ExpressionTable
                                     , ifStmtTables :: [StatementTable]
                                     }
                    | IfElseTable    { ifElseExprTable   :: ExpressionTable
                                     , ifElseStmtTables1 :: [StatementTable]
                                     , ifElseStmtTables2 :: [StatementTable]
                                     }
                    | WhileTable     { whileExprTable  :: ExpressionTable
                                     , whileStmtTables :: [StatementTable]
                                     } 
                    | CallTable      { procIdentifier :: Identifier
                                     , argExprTables  :: [ExpressionTable]
                                     , callParamList  :: [Parameter]
                                     } deriving (Show, Eq)

data VariableSubTable = VariableSubTable { varName                :: Identifier
                                         , varShapeIndicatorTable :: ShapeIndicatorTable
                                         } deriving (Show, Eq)

data ShapeIndicatorTable = ArrayTable  { arrayExprTable   :: ExpressionTable }
                         | MatrixTable { matrixMExprTable :: ExpressionTable
                                       , matrixNExprTable :: ExpressionTable
                                       }
                         | NoIndicatorTable
                         deriving (Show, Eq)

data ExpressionTable = VariableTable   { variable     :: VariableSubTable
                                       , variableType :: BaseType
                                       }
                     | BoolTable       { boolVal   :: Bool }
                     | IntTable        { intVal    :: Int }
                     | FloatTable      { floatVal  :: Float }
                     | StringTable     { stringVal :: String }
                     | AddTable        { addLeftVal  :: ExpressionTable
                                       , addRightVal :: ExpressionTable
                                       , addType     :: BaseType
                                       }
                     | SubTable        { subLeftVal  :: ExpressionTable
                                       , subRightVal :: ExpressionTable
                                       , subType     :: BaseType
                                       }
                     | MulTable        { mulLeftVal  :: ExpressionTable
                                       , mulRightVal :: ExpressionTable
                                       , mulType     :: BaseType
                                       }
                     | DivTable        { divLeftVal  :: ExpressionTable
                                       , divRightVal :: ExpressionTable
                                       , divType     :: BaseType
                                       }
                     | OrTable         { orLeftExprTable  :: ExpressionTable
                                       , orRightExprTable :: ExpressionTable
                                       , orType           :: BaseType
                                       }
                     | AndTable        { andLeftExprTable  :: ExpressionTable
                                       , andRightExprTable :: ExpressionTable
                                       , andType           :: BaseType
                                       }
                     | EqTable         { eqLeftExpr  :: ExpressionTable
                                       , eqRightExpr :: ExpressionTable
                                       , eqType      :: BaseType
                                       }
                     | NotEqTable      { notEqLeftExpr  :: ExpressionTable
                                       , notEqRightExpr :: ExpressionTable
                                       , notEqType      :: BaseType
                                       }
                     | LesTable        { lesLeftExpr  :: ExpressionTable
                                       , lesRightExpr :: ExpressionTable
                                       , lesType      :: BaseType
                                       }
                     | LesEqTable      { lesEqLeftExpr  :: ExpressionTable
                                       , lesEqRightExpr :: ExpressionTable
                                       , lesEqType      :: BaseType
                                       }
                     | GrtTable        { grtLeftExpr  :: ExpressionTable
                                       , grtRightExpr :: ExpressionTable
                                       , grtType      :: BaseType
                                       }
                     | GrtEqTable      { grtEqLeftExpr  :: ExpressionTable
                                       , grtEqRightExpr :: ExpressionTable
                                       , grtEqType      :: BaseType
                                       }
                     | NegativeTable   { negativeExpr :: ExpressionTable
                                       , negativeType :: BaseType
                                       }
                     | NotTable        { notExprTable :: ExpressionTable
                                       , notType      :: BaseType
                                       } deriving (Show, Eq)
============================================
src/MainAnalyzer.hs
17:43:38_Wednesday_29_May_2019
============================================
module MainAnalyzer where

import           AnalyzerUtil
import           GoatAST
import           GoatExit

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the codes that analyze main procedure.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Check whether the main procedure is parameter-less.
---------------------------------------------------------------------------------
checkMainParam :: [Parameter] -> IO Task
checkMainParam [] = return Unit
checkMainParam _  = do
  exitWithError "'main()' procedure should be parameter-less." MainWithParam

-------------------------------------------------------------------------------
-- Check the number of main procedure.
-------------------------------------------------------------------------------
checkMainNum :: Int -> IO Task
checkMainNum numMain
  | 0 == numMain = do
      exitWithError "There is no 'main()' procedure." MissingMain
  | 1 == numMain = return Unit
  | otherwise = do
      exitWithError "There is more than one 'main()' procedure" MultipleMain

-------------------------------------------------------------------------------
-- Get the list of main procedure.
-------------------------------------------------------------------------------
getMainProcedureList :: [Procedure] -> [Procedure]
getMainProcedureList [] = []
getMainProcedureList (proc:procs)
  | "main" == (getProcedureIdentifier proc) = proc : getMainProcedureList procs
  | otherwise = getMainProcedureList procs

checkMainProc :: GoatProgram -> IO ()
checkMainProc program = do
  { let mainList = getMainProcedureList $ procedures program
  ; checkMainNum $ length $ mainList
  ; checkMainParam $ parameters $ header $ head mainList
  ; return ()
  }
============================================
src/Analyze.hs
17:43:35_Wednesday_29_May_2019
============================================
module Analyze where

import qualified Data.Map.Strict as M
import           Data.Maybe
import           GoatAST
import           GoatConstant
import           GoatExit
import           SymbolTable
import           Util

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the codes that analyze AST's semantics.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------- Utility Code ---------------------------------

-------------------------------------------------------------------------------
-- lookup parameter Map, It must have a base type
-------------------------------------------------------------------------------
lookupBaseTypeParamMap :: Identifier -> M.Map Identifier (Int, Parameter) -> BaseType
lookupBaseTypeParamMap varName paramMap =
    case M.lookup varName paramMap of
      Just parameter -> passingType (snd parameter)

-------------------------------------------------------------------------------
-- lookup variable Map, It must have a base type
-------------------------------------------------------------------------------
lookupBaseTypeVarMap ::
  Identifier -> M.Map Identifier VariableDeclaration -> BaseType
lookupBaseTypeVarMap varName varMap =
      case M.lookup varName varMap of
        Just variable -> declarationType variable

-------------------------------------------------------------------------------
-- Get procedure identifier from procedure.
-------------------------------------------------------------------------------
getProcedureIdentifier :: Procedure -> Identifier
getProcedureIdentifier = headerIdent . header

-------------------------------------------------------------------------------
-- Get parameters list from procedure.
-------------------------------------------------------------------------------
getProcedureParameters :: Procedure -> [Parameter]
getProcedureParameters = parameters . header


getMultipleVarDeclarationErrorMessage :: Identifier -> Identifier -> String
getMultipleVarDeclarationErrorMessage varName procName =
  "There are multiple variable declaration named " ++
  (wrapWithDoubleQuotations varName) ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithMultipleVarDeclaration :: Identifier -> Identifier -> IO Task
exitWithMultipleVarDeclaration varName procName =
  exitWithError
  (getMultipleVarDeclarationErrorMessage varName procName)
  MultipleVar

getConditionTypeErrorMessage :: Identifier -> String
getConditionTypeErrorMessage procName =
  "If condition type error! The type must be bool. In procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithConditionTypeError :: Identifier -> IO Task
exitWithConditionTypeError procName =
  exitWithError
  (getConditionTypeErrorMessage procName)
  IfCondError

getLogicExprTypeErrorMessage :: Identifier -> String -> String
getLogicExprTypeErrorMessage procName operator =
  operatorWithQuotationMarks ++
  " type error! The argument of " ++
  operatorWithQuotationMarks ++
  " must be bool. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where operatorWithQuotationMarks = wrapWithDoubleQuotations operator

exitWithLogicExprTypeError :: Identifier -> String -> IO Task
exitWithLogicExprTypeError procName operator =
  exitWithError
  (getLogicExprTypeErrorMessage procName operator)
  LogicOpTypeError

getUndefinedVariableErrorMessage :: Identifier -> String
getUndefinedVariableErrorMessage varName =
  "There is a undefined variable named " ++
  (wrapWithDoubleQuotations varName) ++
  " in the statement"

exitWithUndefinedVariable :: Identifier -> IO Task
exitWithUndefinedVariable varName =
  exitWithError
  (getUndefinedVariableErrorMessage varName)
  UndefinedVar

exitWithReadIncorrect :: IO Task
exitWithReadIncorrect =
  exitWithError "Cannot read into non-variable" ReadIncorrect

exitWithTypeError :: Identifier -> IO Task
exitWithTypeError procName =
  exitWithError ("There is a Type Error in the Statment in proc: " ++
                (wrapWithDoubleQuotations procName)) UnmatchedType

getProcNotFoundMessage :: Identifier -> String -> String
getProcNotFoundMessage procName calledProcName =
  "Call Statement Error! Called Procedure " ++
  (wrapWithDoubleQuotations calledProcName) ++
  " is not found in procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithProcNotFound :: Identifier -> String -> IO Task
exitWithProcNotFound procName calledProcName =
  exitWithError
  (getProcNotFoundMessage procName calledProcName)
  UndefinedProc

getCallParamLengthDiffMessage :: Identifier -> String -> String
getCallParamLengthDiffMessage procName calledProcId =
  "Call Statement Error! The parameter of called procedure " ++
  (wrapWithDoubleQuotations calledProcId) ++
  " does not match the declaration in procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithCallParamLengthDiff :: Identifier -> String -> IO Task
exitWithCallParamLengthDiff procName calledProcId =
  exitWithError
  (getCallParamLengthDiffMessage procName calledProcId)
  CallParamNotMatch

getComparisonExprTypeErrorMessage :: Identifier -> String -> String
getComparisonExprTypeErrorMessage procName operator =
  operatorWithQuotationMarks ++
  " type error! The argument of " ++
  operatorWithQuotationMarks ++
  " must be base type. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where operatorWithQuotationMarks = wrapWithDoubleQuotations operator

exitWithComparisonTypeError :: Identifier -> String -> IO Task
exitWithComparisonTypeError procName operator =
  exitWithError
  (getComparisonExprTypeErrorMessage procName operator)
  ComparisonError

getNotSameTypeErrorMessage :: Identifier -> String -> String
getNotSameTypeErrorMessage procName operator =
  operatorWithQuotationMarks ++
  " type error! The argument of " ++
  operatorWithQuotationMarks ++
  " must be same base type. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where operatorWithQuotationMarks = wrapWithDoubleQuotations operator

exitWithNotSameTypeError :: Identifier -> String -> IO Task
exitWithNotSameTypeError procName operator =
  exitWithError
  (getNotSameTypeErrorMessage procName operator)
  NotSameTypeError

getUnaryMinusTypeErrorMessage :: Identifier -> String
getUnaryMinusTypeErrorMessage procName =
  unaryMinusString ++
  " type error! The argument of " ++
  unaryMinusString ++
  " must be int or float. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where unaryMinusString = "\"-\" (Unary Minus)"


exitWithUnaryMinusError :: Identifier -> IO Task
exitWithUnaryMinusError procName =
  exitWithError
  (getUnaryMinusTypeErrorMessage procName)
  UnaryMinusError

getAssignTypeErrorMessage :: Identifier -> String -> String
getAssignTypeErrorMessage procName varName =
  "Assign Type Error! The type of " ++
  (wrapWithDoubleQuotations varName) ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName) ++
  " is not match."

exitWithAssignTypeError :: Identifier -> String -> IO Task
exitWithAssignTypeError procName varName =
  exitWithError
  (getAssignTypeErrorMessage procName varName)
  AssignTypeError

getVarIndicatorErrorMessage :: Identifier -> String -> String
getVarIndicatorErrorMessage procName varName =
  "Variable indicator Error! The variable " ++
  (wrapWithDoubleQuotations varName) ++
  " should not be Array or Matrix in procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithVarIndicatorError :: Identifier -> String -> IO Task
exitWithVarIndicatorError procName varName =
  exitWithError
  (getVarIndicatorErrorMessage procName varName)
  VarIndicatorError

getVarIndicatorNotSameMessage :: Identifier -> String -> String
getVarIndicatorNotSameMessage procName varName =
  "Variable indicator Error! The indicator of variable " ++
  (wrapWithDoubleQuotations varName) ++
  " is not same as declaration" ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithVarIndicatorNotSame :: Identifier -> String -> IO Task
exitWithVarIndicatorNotSame procName varName =
  exitWithError
  (getVarIndicatorNotSameMessage procName varName)
  VarIndicatorError

getArrayMatrixIndicatorTypeErrorMessage :: Identifier -> String -> String
getArrayMatrixIndicatorTypeErrorMessage procName varName =
  "Array and Matrix dimension type Error! The dimension of Array and Matrix" ++
  " must be Int. For variable  "++
  (wrapWithDoubleQuotations varName) ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName)

exitArrayMatrixDimensionTypeError :: Identifier -> String -> IO Task
exitArrayMatrixDimensionTypeError procName varName =
  exitWithError
  (getArrayMatrixIndicatorTypeErrorMessage procName varName)
  VarIndicatorError

getDuplicateProcedureErrorMessage :: Identifier -> String
getDuplicateProcedureErrorMessage procName =
  "There are multiple procedures named " ++ (wrapWithDoubleQuotations procName)


exitWithDuplicateProcedure :: Identifier -> IO Task
exitWithDuplicateProcedure procName =
  exitWithError
  (getDuplicateProcedureErrorMessage procName)
  MultipleProc

getInvalidCallExprMessage :: Identifier -> Identifier -> String
getInvalidCallExprMessage procName calledProcId =
  "Invalid Call statement arguments! The argument of call statement for " ++
  "procedure " ++
  (wrapWithDoubleQuotations calledProcId) ++
  " should only be variable in procedure " ++
  (wrapWithDoubleQuotations procName)

exitWithInvalidCallExpr :: Identifier -> Identifier -> IO Task
exitWithInvalidCallExpr procName calledProcId =
  exitWithError
  (getInvalidCallExprMessage procName calledProcId)
  MultipleProc

-------------------------------- Utility Code ---------------------------------


-------------------------------- Analyzer Code --------------------------------

-------------------------------------------------------------------------------
-- analyze Procedure
-------------------------------------------------------------------------------
analyze :: [Procedure] -> ProgramMap -> Either (IO Task) ProgramMap
analyze procedures procMap = do
    let procMapWithoutStatements = insertProcListWithoutStatements procedures procMap
    case procMapWithoutStatements of
        Left err         -> Left err
        Right programMap -> insertStatementsInProcList procedures programMap

insertStatementsInProcList :: [Procedure] -> ProgramMap -> Either (IO Task) ProgramMap
insertStatementsInProcList (proc:[]) procMap = do
    let statementsEither = insertStatementList procedureName (bodyStatements procedureBody) paramMap varMap procMap
        procedureName = getProcedureIdentifier proc
        procedureBody = (body proc)
        procedureTable = procMap M.! procedureName
        paramMap = parameterMap procedureTable
        varMap = variableMap procedureTable
    case statementsEither of
        Left err -> Left err
        Right statements -> do
              let newProcTable = ProcedureTable paramMap varMap statements
              Right $ M.insert procedureName newProcTable procMap

insertStatementsInProcList (proc:procs) procMap = do
    let statementsEither = insertStatementList procedureName (bodyStatements procedureBody) paramMap varMap procMap
        procedureName = getProcedureIdentifier proc
        procedureBody = (body proc)
        procedureTable = procMap M.! procedureName
        paramMap = parameterMap procedureTable
        varMap = variableMap procedureTable
    case statementsEither of
        Left err -> Left err
        Right statements -> do
              let newProcMapEither = insertStatementsInProcList procs procMap
                  newProcTable = ProcedureTable paramMap varMap statements
              case newProcMapEither of
                Left err -> Left err
                Right newProcMap -> Right $ M.insert procedureName newProcTable newProcMap


insertProcListWithoutStatements :: [Procedure] -> ProgramMap -> Either (IO Task) ProgramMap
insertProcListWithoutStatements (proc:[]) procMap = do
    let procTable = insertProcedureTableWithoutStatement proc procMap
    case procTable of
        Left err           -> Left err
        Right subProcTable -> Right $ M.insert procName subProcTable procMap
    where procName = getProcedureIdentifier proc
insertProcListWithoutStatements (proc:procs) procMap = do
  let newProcMap = insertProcListWithoutStatements procs procMap
  case newProcMap of
    Left err -> Left err
    Right subProcMap -> do
      let procName = getProcedureIdentifier proc
      case (M.member procName subProcMap) of
        True  -> Left $ exitWithDuplicateProcedure procName
        False -> do
          let procTable = insertProcedureTableWithoutStatement proc procMap
          case procTable of
            Left err -> Left err
            Right subProcTable ->
              Right $ M.insert procName subProcTable subProcMap

insertProcedureTableWithoutStatement :: Procedure -> ProgramMap -> Either (IO Task) ProcedureTable
insertProcedureTableWithoutStatement procedure procMap = do
  let  paramMap = insertParameterMap procedureName procedureParameters 0 M.empty
       procedureBody = (body procedure)
       procedureName = getProcedureIdentifier procedure
       procedureParameters = getProcedureParameters procedure
  case paramMap of
          Left err -> Left err
          Right subParamMap -> do
              let varMap = insertVariableMap
                            procedureName
                            (bodyVarDeclarations procedureBody)
                            subParamMap
                            M.empty
              case varMap of
                  Left err -> Left err
                  Right subVarMap -> Right $ ProcedureTable subParamMap subVarMap []

insertParameterMap ::
  Identifier -> [Parameter] -> Int -> ParameterMap -> Either (IO Task) ParameterMap
insertParameterMap _ [] _ paramMap = Right paramMap
insertParameterMap _ (param:[]) index paramMap =
  Right $ M.insert (passingIdent param) (index, param) paramMap
insertParameterMap procName (param:params) index paramMap = do
  let newParamMap = insertParameterMap procName params (index+1) paramMap
  case newParamMap of
    Left err -> Left err
    Right subParamMap -> do
      let paramName = (passingIdent param)
      case (M.member paramName subParamMap) of
        True  -> Left $ exitWithMultipleVarDeclaration paramName procName
        False -> Right $ M.insert paramName (index, param) subParamMap


insertVariableMap ::
  Identifier -> [VariableDeclaration] -> ParameterMap -> VariableMap -> Either (IO Task) VariableMap
insertVariableMap procName [] paramMap varMap = Right varMap
insertVariableMap procName (bodyVarDecl:[]) paramMap varMap = do
  let varName = varId $ declarationVariable bodyVarDecl
  case (M.member varName paramMap) of
    True  -> Left $ exitWithMultipleVarDeclaration varName procName
    False -> Right $ M.insert varName bodyVarDecl varMap
insertVariableMap procName (bodyVarDecl:bodyVarDecls) paramMap varMap = do
  let varName = varId $ declarationVariable bodyVarDecl
  case (M.member varName paramMap) of
    True  -> Left $ exitWithMultipleVarDeclaration varName procName
    False -> do
      let newVarMap = insertVariableMap procName bodyVarDecls paramMap varMap
      case newVarMap of
        Left err -> Left err
        Right subVarMap -> do
          case (M.member varName subVarMap) of
            True  -> Left $ exitWithMultipleVarDeclaration varName procName
            False -> Right $ M.insert varName bodyVarDecl subVarMap

insertStatementList :: Identifier -> [Statement] -> ParameterMap -> VariableMap -> ProgramMap -> Either (IO Task) [StatementTable]
insertStatementList procName (stmt:[]) paramMap varMap procMap = do
  let newStmtTable = checkStatement procName stmt paramMap varMap procMap
  case newStmtTable of
    Left err        -> Left err
    Right stmtTable -> Right $ (stmtTable):[]
insertStatementList procName (stmt:stmts) paramMap varMap procMap = do
  let newStatements = insertStatementList procName stmts paramMap varMap procMap
  case newStatements of
    Left err            -> Left err
    Right subStatements -> do
      let newStmtTable = checkStatement procName stmt paramMap varMap procMap
      case newStmtTable of
        Left err        -> Left err
        Right stmtTable -> Right $ (stmtTable):subStatements

checkStatement :: Identifier -> Statement -> ParameterMap -> VariableMap -> ProgramMap -> Either (IO Task) StatementTable
checkStatement procName stmt paramMap varMap procMap =
  case stmt of
    Write expr -> checkWriteStmt procName expr paramMap varMap
    Read var -> do
      let eitherReadStatement = checkReadStmt procName var paramMap varMap
      case eitherReadStatement of
          Left err        -> Left err
          Right exprTable -> Right $ ReadTable exprTable
    Assign var expression -> do
      -- Assignment statement, e.g. a := 1
      let eitherVariableTable = checkVariable procName var paramMap varMap
      case eitherVariableTable of
          Left err            -> Left err
          Right variableTable -> do
              checkAssignExpr procName expression variableTable paramMap varMap
    If expr stmts -> do
      let exprEither = checkCondition procName expr paramMap varMap
      case exprEither of
        Left err -> Left err
        Right exprTable -> do
          let stmtTablesEither = insertStatementList procName stmts paramMap varMap procMap
          case stmtTablesEither of
            Left err         -> Left err
            Right stmtTables -> Right $ IfTable exprTable stmtTables
    IfElse expr stmts1 stmts2 -> do
      let exprEither = checkCondition procName expr paramMap varMap
      case exprEither of
        Left err -> Left err
        Right exprTable -> do
          let stmtTablesEither1 = insertStatementList procName stmts1 paramMap varMap procMap
          case stmtTablesEither1 of
            Left err -> Left err
            Right stmtTables1 -> do
              let stmtTablesEither2 = insertStatementList procName stmts2 paramMap varMap procMap
              case stmtTablesEither2 of
                Left err -> Left err
                Right stmtTables2 -> do
                  Right $ IfElseTable exprTable stmtTables1 stmtTables2
    While expr stmts -> do
      let exprEither = checkCondition procName expr paramMap varMap
      case exprEither of
        Left err -> Left err
        Right exprTable -> do
          let stmtTablesEither = insertStatementList procName stmts paramMap varMap procMap
          case stmtTablesEither of
            Left err         -> Left err
            Right stmtTables -> Right $ WhileTable exprTable stmtTables
    Call procId argExprs -> do
      let exprsEither = checkCallStmt procName procId argExprs procMap paramMap varMap
      case exprsEither of
        Left err -> Left err
        Right (expreTables, params) -> Right $ CallTable procId expreTables params

checkArguments ::
  Identifier -> Identifier -> [Expression] -> [BaseType] -> [Parameter] -> ParameterMap -> VariableMap -> Either (IO Task) [ExpressionTable]
--checkArguments procName procId [e] [b] paramMap varMap = do
checkArguments procName procId (e:[]) (b:[]) (parameter:[]) paramMap varMap = do
  let paramIndicator  = (passingIndicator parameter)
      eitherExprTable =
            checkCallExpr procName procId paramIndicator e paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right expressionTable -> do
      let exprBaseType = getAssignBaseType expressionTable
      if (exprBaseType == b)
      then Right [expressionTable]
      else if (FloatType == b && IntType == exprBaseType)
           then Right [expressionTable]
           else Left $ exitWithCallParamLengthDiff procName procId
checkArguments procName procId (e:es) (b:bs) (parameter:parameters) paramMap varMap = do
  let expressionTables = checkArguments procName procId es bs parameters paramMap varMap
  case expressionTables of
    Left err -> Left err
    Right exprTables -> do
      let paramIndicator  = (passingIndicator parameter)
          eitherExprTable =
                checkCallExpr procName procId paramIndicator e paramMap varMap
      case eitherExprTable of
        Left err -> Left err
        Right expressionTable -> do
          let exprBaseType = getAssignBaseType expressionTable
          if (exprBaseType == b)
          then Right $ [expressionTable] ++ exprTables
          else if ((FloatType == b) && (IntType == exprBaseType))
               then Right $ [expressionTable] ++ exprTables
               else Left $ exitWithCallParamLengthDiff procName procId

checkCallExpr ::
  Identifier -> Identifier -> ParameterIndicator -> Expression -> ParameterMap -> VariableMap
  -> Either (IO Task) ExpressionTable
checkCallExpr procName procId paramIndicator expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right expressionTable -> do
      case paramIndicator of
        VarType -> Right expressionTable
        RefType -> do
          case expressionTable of
             VariableTable _ _ -> Right  expressionTable
             otherwise         -> Left $ exitWithInvalidCallExpr procName procId


paramMapToList :: ParameterMap -> [Parameter]
paramMapToList paramMap =
  [(snd param) | param <- paramNewList]
  where paramList = M.toList paramMap;
        paramOrderedMap = M.fromList [snd param | param <- paramList]
        paramNewList = M.toList paramOrderedMap

checkCallStmt ::
  Identifier -> Identifier -> [Expression] -> ProgramMap -> ParameterMap -> VariableMap -> Either (IO Task) ([ExpressionTable], [Parameter])
checkCallStmt procName calledProcId argExprs procMap paramMap varMap = do
  case M.lookup calledProcId procMap of
    Just calledProcTable -> do
      let paramList = paramMapToList $ parameterMap calledProcTable
          paramBaseTypes = [passingType param | param <- paramList]
      case ((length argExprs) == (length paramList)) of
        True -> do
          case ((length argExprs) == 0) of
            True -> Right ([], [])
            otherwise -> do
              let expreTables = checkArguments procName calledProcId argExprs paramBaseTypes paramList paramMap varMap
              case expreTables of
                Left err               -> Left err
                Right expressionTables -> Right (expressionTables, paramList)
        otherwise -> Left $ exitWithCallParamLengthDiff procName calledProcId
    Nothing -> Left $ exitWithProcNotFound procName calledProcId

checkWriteStmt :: Identifier -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) StatementTable
checkWriteStmt procName expr paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
  case eitherExpressionTable of
    Left err        -> Left err
    Right exprTable -> Right $ WriteTable exprTable

checkReadStmt :: Identifier -> Variable -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkReadStmt procName var paramMap varMap = do
  let eitherExpressionTable = checkVariable procName var paramMap varMap
  case eitherExpressionTable of
    Left err        -> Left err
    Right exprTable -> Right $ exprTable

checkAssignExpr ::
  Identifier -> Expression -> ExpressionTable -> ParameterMap -> VariableMap -> Either (IO Task) StatementTable
checkAssignExpr procName expr variableTable paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
  case eitherExpressionTable of
    Left err        -> Left err
    Right expressionTable -> do
      let exprType = getAssignBaseType expressionTable
      checkAssignType procName variableTable expressionTable exprType

checkCondition :: Identifier -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkCondition procName expr paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
      errorExit = exitWithConditionTypeError procName
  case eitherExpressionTable of
    Left err -> Left err
    Right exprTable -> do
      case exprTable of
        BoolTable _      -> Right exprTable
        OrTable _ _ _    -> Right exprTable
        AndTable _ _ _   -> Right exprTable
        NotTable _ _     -> Right exprTable
        EqTable _ _ _    -> Right exprTable
        NotEqTable _ _ _ -> Right exprTable
        LesTable _ _ _   -> Right exprTable
        LesEqTable _ _ _ -> Right exprTable
        GrtTable _ _ _   -> Right exprTable
        GrtEqTable _ _ _ -> Right exprTable
        otherwise        -> Left errorExit

checkExpression :: Identifier -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkExpression procName expr paramMap varMap = do
  case expr of
    BoolConst  val -> Right $ BoolTable val
    IntConst   val -> Right $ IntTable val
    FloatConst val -> Right $ FloatTable val
    StrConst   val -> Right $ StringTable val
    ExprVar    val -> do
      let eitherVariableExpression = checkVariable procName val paramMap varMap
      case eitherVariableExpression of
          Left err                 -> Left err
          Right variableExpression -> Right variableExpression
    Add lExpr rExpr -> do
      let eitherAddExpression = checkOperationExpression procName addSymbol lExpr rExpr paramMap varMap
      case eitherAddExpression of
          Left err            -> Left err
          Right addExpression -> Right addExpression
    Mul lExpr rExpr -> do
      let eitherMulExpression = checkOperationExpression procName timesSymbol lExpr rExpr paramMap varMap
      case eitherMulExpression of
          Left err            -> Left err
          Right mulExpression -> Right mulExpression
    Sub lExpr rExpr -> do
      let eitherSubExpression = checkOperationExpression procName minusSymbol lExpr rExpr paramMap varMap
      case eitherSubExpression of
          Left err            -> Left err
          Right subExpression -> Right subExpression
    Div lExpr rExpr -> do
      let eitherDivExpression = checkOperationExpression procName divSymbol lExpr rExpr paramMap varMap
      case eitherDivExpression of
          Left err            -> Left err
          Right divExpression -> Right divExpression
    Or    lExpr rExpr ->
      checkLogicExpression   procName "||" lExpr rExpr paramMap varMap
    And   lExpr rExpr ->
      checkLogicExpression   procName "&&" lExpr rExpr paramMap varMap
    Eq    lExpr rExpr ->
      checkCompareExpression procName "="  lExpr rExpr paramMap varMap
    NotEq lExpr rExpr ->
      checkCompareExpression procName "!=" lExpr rExpr paramMap varMap
    Les   lExpr rExpr ->
      checkCompareExpression procName "<"  lExpr rExpr paramMap varMap
    LesEq lExpr rExpr ->
      checkCompareExpression procName "<=" lExpr rExpr paramMap varMap
    Grt   lExpr rExpr ->
      checkCompareExpression procName ">"  lExpr rExpr paramMap varMap
    GrtEq lExpr rExpr ->
      checkCompareExpression procName ">=" lExpr rExpr paramMap varMap
    UnaryMinus  expr  -> checkUnaryMinus procName expr paramMap varMap
    UnaryNot    expr  -> checkUnaryNot   procName expr paramMap varMap

checkLogicExpression ::
  Identifier -> String -> Expression -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkLogicExpression procName operator lExpr rExpr paramMap varMap = do
  let lExprTableEither = checkLogicSubExpression procName operator lExpr paramMap varMap
  case lExprTableEither of
    Left err -> Left err
    Right lExprTable -> do
      let rExprTableEither = checkLogicSubExpression procName operator rExpr paramMap varMap
      case rExprTableEither of
        Left err -> Left err
        Right rExprTable -> do
          case operator of
            "||" -> Right $ OrTable lExprTable rExprTable BoolType
            "&&" -> Right $ AndTable lExprTable rExprTable BoolType

checkLogicSubExpression ::
  Identifier -> String -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkLogicSubExpression procName operator expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right exprTable -> do
      let errorExit = exitWithLogicExprTypeError procName operator
      case exprTable of
        VariableTable _ _ -> checkBoolType exprTable errorExit
        BoolTable  _      -> Right exprTable
        OrTable    _ _ _  -> checkBoolType exprTable errorExit
        AndTable   _ _ _  -> checkBoolType exprTable errorExit
        EqTable    _ _ _  -> checkBoolType exprTable errorExit
        NotEqTable _ _ _  -> checkBoolType exprTable errorExit
        LesTable   _ _ _  -> checkBoolType exprTable errorExit
        LesEqTable _ _ _  -> checkBoolType exprTable errorExit
        GrtTable   _ _ _  -> checkBoolType exprTable errorExit
        GrtEqTable _ _ _  -> checkBoolType exprTable errorExit
        NotTable   _ _    -> checkBoolType exprTable errorExit
        otherwise -> Left errorExit

checkUnaryNot ::
  Identifier -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkUnaryNot procName expr paramMap varMap = do
  let eitherUnaryNotExpression = checkLogicSubExpression procName "!" expr paramMap varMap
  case eitherUnaryNotExpression of
    Left err                 -> Left err
    Right unaryNotExpression -> Right (NotTable unaryNotExpression BoolType)

checkCompareExpression ::
  Identifier -> String -> Expression -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkCompareExpression procName operator lExpr rExpr paramMap varMap = do
  let lExprTableEither = checkCompareSubExpression procName operator lExpr paramMap varMap
  case lExprTableEither of
    Left err -> Left err
    Right lExprTable -> do
      let rExprTableEither = checkCompareSubExpression procName operator rExpr paramMap varMap
      case rExprTableEither of
        Left err -> Left err
        Right rExprTable -> do
          case operator of
            "="  -> checkSameType procName operator lExprTable rExprTable
            "!=" -> checkSameType procName operator lExprTable rExprTable
            "<"  -> checkBaseType procName operator lExprTable rExprTable
            "<=" -> checkBaseType procName operator lExprTable rExprTable
            ">"  -> checkBaseType procName operator lExprTable rExprTable
            ">=" -> checkBaseType procName operator lExprTable rExprTable

checkCompareSubExpression ::
  Identifier -> String -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkCompareSubExpression procName operator expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
      errorExit = exitWithComparisonTypeError procName operator
  case eitherExprTable of
    Left err -> Left err
    Right exprTable -> do
      case exprTable of
       StringTable _ -> Left errorExit
       otherwise     -> Right exprTable

checkUnaryMinus ::
  Identifier -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkUnaryMinus procName expr paramMap varMap = do
  let exprTableEither = checkExpression procName expr paramMap varMap
  case exprTableEither of
    Left err -> Left err
    Right exprTable -> do
      let exprTypeEither = checkUnaryMinusType procName exprTable
      case exprTypeEither of
        Left err       -> Left err
        Right exprType -> Right $ NegativeTable exprTable exprType

checkUnaryMinusType ::
  Identifier -> ExpressionTable -> Either (IO Task) BaseType
checkUnaryMinusType procName exprTable = do
  let errorExit = exitWithUnaryMinusError procName
  case exprTable of
    VariableTable _   exprType -> checkNotBoolType exprType errorExit
    IntTable      _            -> Right IntType
    FloatTable    _            -> Right FloatType
    AddTable      _ _ exprType -> checkNotBoolType exprType errorExit
    SubTable      _ _ exprType -> checkNotBoolType exprType errorExit
    MulTable      _ _ exprType -> checkNotBoolType exprType errorExit
    DivTable      _ _ exprType -> checkNotBoolType exprType errorExit
    NegativeTable _   exprType -> checkNotBoolType exprType errorExit
    otherwise                  -> Left errorExit

checkBoolType ::
  ExpressionTable -> IO Task -> Either (IO Task) ExpressionTable
checkBoolType exprTable errorExit = do
  let exprType = getAssignBaseType exprTable
  case exprType of
    BoolType  -> Right exprTable
    otherwise -> Left errorExit

checkNotBoolType :: BaseType -> IO Task -> Either (IO Task) BaseType
checkNotBoolType exprType errorExit =
  case exprType of
    BoolType  -> Left errorExit
    otherwise -> Right exprType

-------------------------------------------------------------------------------
-- Note: Please filter the StringTable before using this function
--       Cannot be used for String
-- Check whether the type of given ExpressionTables are the same
-------------------------------------------------------------------------------
checkSameType ::
  Identifier -> String -> ExpressionTable -> ExpressionTable ->
  Either (IO Task) ExpressionTable
checkSameType procName operator lExpr rExpr = do
  let lType = getBaseType lExpr
      rType = getBaseType rExpr
  if lType == rType
    then Right (getComparisonTable operator lExpr rExpr lType)
    else Left (exitWithNotSameTypeError procName operator)

checkBaseType ::
  Identifier -> String -> ExpressionTable -> ExpressionTable ->
  Either (IO Task) ExpressionTable
checkBaseType procName operator lExpr rExpr = do
  let lType = getBaseType lExpr
      rType = getBaseType rExpr
  if lType /= rType
    then do
      { let exprTypeEither = getExpressionTableType procName lExpr rExpr
      ; case exprTypeEither of
          Left err -> Left err
          Right exprType ->
            Right (getComparisonTable operator lExpr rExpr exprType)
      }
    else Right (getComparisonTable operator lExpr rExpr lType)

getComparisonTable ::
  String -> ExpressionTable -> ExpressionTable -> BaseType -> ExpressionTable
getComparisonTable operator lExpr rExpr baseType =
  case operator of
    "="  -> EqTable    lExpr rExpr baseType
    "!=" -> NotEqTable lExpr rExpr baseType
    "<"  -> LesTable   lExpr rExpr baseType
    "<=" -> LesEqTable lExpr rExpr baseType
    ">"  -> GrtTable   lExpr rExpr baseType
    ">=" -> GrtEqTable lExpr rExpr baseType

-------------------------------------------------------------------------------
-- Note: Please filter the StringTable before using this function
--       Cannot be used for String
-- Return the BaseType of given ExpressionTable
-------------------------------------------------------------------------------
getBaseType :: ExpressionTable -> BaseType
getBaseType exprTable =
  case exprTable of
    VariableTable _ exprType -> exprType
    BoolTable  _             -> BoolType
    IntTable   _             -> IntType
    FloatTable _             -> FloatType
    AddTable   _ _  exprType -> exprType
    SubTable   _ _  exprType -> exprType
    MulTable   _ _  exprType -> exprType
    DivTable   _ _  exprType -> exprType
    OrTable    _ _  exprType -> exprType
    AndTable   _ _  exprType -> exprType
    EqTable    _ _  exprType -> exprType
    NotEqTable _ _  exprType -> exprType
    LesTable   _ _  exprType -> exprType
    LesEqTable _ _  exprType -> exprType
    GrtTable   _ _  exprType -> exprType
    GrtEqTable _ _  exprType -> exprType
    NegativeTable _ exprType -> exprType
    NotTable      _ exprType -> exprType

checkAssignType ::
  Identifier -> ExpressionTable -> ExpressionTable -> BaseType -> Either (IO Task) StatementTable
checkAssignType procName variableTable expressionTable exprType = do
    let varType      = variableType variableTable
        variableName = varName $ variable variableTable
    if varType == exprType
        then Right $ AssignTable variableTable expressionTable
        else if (FloatType == varType) && (IntType == exprType)
            then Right $ AssignTable variableTable expressionTable
            else Left $ exitWithAssignTypeError procName variableName

checkVariable ::
  Identifier -> Variable -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkVariable procName var paramMap varMap = do
  case (M.member id paramMap) of
    True  -> checkParamIndicator procName var paramBaseType
    False -> do
      case (M.member id varMap) of
          True  -> checkVariableIndicator procName var varDecl varBaseType paramMap varMap
          False -> Left $ exitWithUndefinedVariable id
      where varDecl     = varMap M.! id
            varBaseType = lookupBaseTypeVarMap id varMap
  where id = varId var
        paramBaseType = lookupBaseTypeParamMap id paramMap

checkParamIndicator ::
  Identifier -> Variable -> BaseType -> Either (IO Task) ExpressionTable
checkParamIndicator procName var paramBaseType = do
  case varIndicator of
    NoIndicator -> Right $ VariableTable varSubTable paramBaseType
    otherwise   -> Left  $ exitWithVarIndicatorError procName id
  where id = varId var
        varIndicator = varShapeIndicator var
        varSubTable  = VariableSubTable id NoIndicatorTable

checkVariableIndicator ::
  Identifier -> Variable -> VariableDeclaration -> BaseType -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkVariableIndicator procName var varDecl varBaseType paramMap varMap = do
  case (varIndicator, declIndicator)of
    (NoIndicator, NoIndicator) -> Right $ VariableTable varSubTable varBaseType
    (Array  n   , Array  _   ) ->
        checkArrayDimension procName n var varBaseType paramMap varMap
    (Matrix m n , Matrix _ _ ) ->
        checkMatrixDimensions procName (m, n) var varBaseType paramMap varMap
    otherwise -> Left  $ exitWithVarIndicatorNotSame procName id
  where id = varId var
        varIndicator  = varShapeIndicator var
        declIndicator = varShapeIndicator $ declarationVariable varDecl
        varSubTable   = VariableSubTable id NoIndicatorTable

checkArrayDimension ::
  Identifier -> Expression -> Variable -> BaseType -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkArrayDimension procName expr var varBaseType paramMap varMap = do
  let varName = varId var
      eitherExpressionTable = checkDimension procName expr varName paramMap varMap
  case eitherExpressionTable of
    Left  err             -> Left err
    Right expressionTable -> do
        let arrayTable = ArrayTable expressionTable
            varSubTable = VariableSubTable varName arrayTable
        Right $ VariableTable varSubTable varBaseType

checkMatrixDimensions ::
  Identifier -> (Expression, Expression) -> Variable -> BaseType -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkMatrixDimensions procName (exprM, exprN) var varBaseType paramMap varMap = do
  let varName = varId var
      eitherExpressionTableM = checkDimension procName exprM varName paramMap varMap
  case eitherExpressionTableM of
    Left  err             -> Left err
    Right expressionTableM -> do
      let eitherExpressionTableN = checkDimension procName exprN varName paramMap varMap
      case eitherExpressionTableN of
        Left  err             -> Left err
        Right expressionTableN -> do
          let matrixTable = MatrixTable expressionTableM expressionTableN
              varSubTable = VariableSubTable varName matrixTable
          Right $ VariableTable varSubTable varBaseType

checkDimension ::
  Identifier -> Expression -> String -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkDimension procName expr varName paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
  case eitherExpressionTable of
    Left  err             -> Left err
    Right expressionTable -> do
      let exprType = getAssignBaseType expressionTable
      case exprType of
        IntType   -> Right expressionTable
        otherwise -> Left $ exitArrayMatrixDimensionTypeError procName varName

checkOperationExpression :: Identifier -> String -> Expression -> Expression -> ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkOperationExpression procName operator lExpr rExpr paramMap varMap = do
  let leftExprTableEither = checkExpression procName lExpr paramMap varMap
  case leftExprTableEither of
    Left err -> Left err
    Right leftExprTable -> do
      let rightExprTableEither = checkExpression procName rExpr paramMap varMap
      case rightExprTableEither of
        Left err -> Left err
        Right rightExprTable -> do
          let baseTypeEither = getExpressionTableType procName leftExprTable rightExprTable
          case baseTypeEither of
            Left err -> Left err
            Right baseType -> Right $ insertExpressionTableByOperator operator leftExprTable rightExprTable baseType

insertExpressionTableByOperator :: String -> ExpressionTable -> ExpressionTable -> BaseType -> ExpressionTable
insertExpressionTableByOperator operator lExpressionTable rExpressionTable baseType
  | operator == addSymbol   = AddTable lExpressionTable rExpressionTable baseType
  | operator == minusSymbol = SubTable lExpressionTable rExpressionTable baseType
  | operator == timesSymbol = MulTable lExpressionTable rExpressionTable baseType
  | operator == divSymbol   = DivTable lExpressionTable rExpressionTable baseType

getExpressionTableType :: Identifier -> ExpressionTable -> ExpressionTable -> Either (IO Task) BaseType
getExpressionTableType procName leftExprTable rightExprTable = do
  case leftExprTable of
    IntTable _ -> do
      case rightExprTable of
        IntTable _               -> Right IntType
        FloatTable _             -> Right FloatType
        VariableTable _ rVarType -> Right rVarType
        AddTable _ _ rAddType    -> Right rAddType
        SubTable _ _ rSubType    -> Right rSubType
        MulTable _ _ rMulType    -> Right rMulType
        DivTable _ _ rDivType    -> Right rDivType
        NegativeTable _ rVarType -> Right rVarType
        otherwise                -> Left $ exitWithTypeError procName
    FloatTable _ -> Right FloatType
    VariableTable _ lVarType -> getSubExpressionTableType procName lVarType rightExprTable
    AddTable    _ _ lAddType -> getSubExpressionTableType procName lAddType rightExprTable
    SubTable    _ _ lSubType -> getSubExpressionTableType procName lSubType rightExprTable
    MulTable    _ _ lMulType -> getSubExpressionTableType procName lMulType rightExprTable
    DivTable    _ _ lDivType -> getSubExpressionTableType procName lDivType rightExprTable
    NegativeTable _ lVarType -> getSubExpressionTableType procName lVarType rightExprTable
    otherwise                -> Left $ exitWithTypeError procName

getSubExpressionTableType :: Identifier -> BaseType -> ExpressionTable -> Either (IO Task) BaseType
getSubExpressionTableType procName baseType expressionTable = do
  case expressionTable of
    IntTable _               -> Right baseType
    FloatTable _             -> Right FloatType
    VariableTable _ rVarType -> chooseType procName baseType rVarType
    AddTable _ _ rAddType    -> chooseType procName baseType rAddType
    SubTable _ _ rSubType    -> chooseType procName baseType rSubType
    MulTable _ _ rMulType    -> chooseType procName baseType rMulType
    DivTable _ _ rDivType    -> chooseType procName baseType rDivType
    NegativeTable _ rVarType -> chooseType procName baseType rVarType
    otherwise                -> Left $ exitWithTypeError procName

chooseType :: Identifier -> BaseType -> BaseType -> Either (IO Task) BaseType
chooseType _ IntType IntType   = Right IntType
chooseType _ FloatType _       = Right FloatType
chooseType _ _ FloatType       = Right FloatType
chooseType procName BoolType _ = Left $ exitWithTypeError procName
chooseType procName _ BoolType = Left $ exitWithTypeError procName

-------------------------------------------------------------------------------
-- Check whether the main procedure is parameter-less.
---------------------------------------------------------------------------------
checkMainParam :: [Parameter] -> IO Task
checkMainParam [] = return Unit
checkMainParam _  = do
  exitWithError "'main()' procedure should be parameter-less." MainWithParam

-------------------------------------------------------------------------------
-- Check the number of main procedure.
-------------------------------------------------------------------------------
checkMainNum :: Int -> IO Task
checkMainNum numMain
  | 0 == numMain = do
      exitWithError "There is no 'main()' procedure." MissingMain
  | 1 == numMain = return Unit
  | otherwise = do
      exitWithError "There is more than one 'main()' procedure" MultipleMain

-------------------------------------------------------------------------------
-- Get the list of main procedure.
-------------------------------------------------------------------------------
getMainProcedureList :: [Procedure] -> [Procedure]
getMainProcedureList [] = []
getMainProcedureList (proc:procs)
  | "main" == (getProcedureIdentifier proc) = proc : getMainProcedureList procs
  | otherwise = getMainProcedureList procs

checkMainProc :: GoatProgram -> IO ()
checkMainProc program = do
  { let mainList = getMainProcedureList $ procedures program
  ; checkMainNum $ length $ mainList
  ; checkMainParam $ parameters $ header $ head mainList
  ; return ()
  }

-------------------------------------------------------------------------------
-- Main entry of semantic Analyze module.
-------------------------------------------------------------------------------
semanticAnalyse :: GoatProgram -> Either (IO Task) ProgramMap
semanticAnalyse program = analyze (procedures program) M.empty
============================================
src/Goat.hs
17:43:37_Wednesday_29_May_2019
============================================
module Main where

import           Analyzer
import           CodeGenerator
import           GoatAST
import           GoatExit
import           GoatParser
import           GoatPrettyPrint
import           MainAnalyzer
import           System.Environment (getArgs, getProgName)
import           Text.Parsec        (runParser)

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This is the main file for Stage 1 of the project of COMP90045, Programming
-- Language Implementation. This file provides two main methods: checkArgs and
-- main.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Given the program name and arguments list, check if it's valid, thrown
-- exception if it's not valid, otherwise return the corresponding Task value.
-------------------------------------------------------------------------------
checkArgs :: String -> [String] -> IO Task
checkArgs _ ['-':_]          = exitWithError "Missing filename" MissingFile
checkArgs _ [filename]       = return Compile
checkArgs _ ["-p", filename] = return Pprint
checkArgs _ ["-a", filename] = return Parse
checkArgs _ ["-s", filename] = return Analyze
checkArgs progname _         = do
  exitWithError ("Usage: " ++ progname ++ " [-ap] filename") WrongUsage

-------------------------------------------------------------------------------
-- Main function of the compiler
-------------------------------------------------------------------------------
main :: IO ()
main
  = do
     progname <- getProgName
     args     <- getArgs
     task     <- checkArgs progname args
     if task == Compile then
       do
         let [filename] = args
         input <- readFile filename
         let output = runParser pMain 0 "" input
         case output of
           Right ast -> do { checkMainProc ast
                           ; let programMap = semanticAnalyse ast
                           ; case programMap of
                                Left err -> do
                                    { err
                                    ; return ()
                                    }
                                Right result -> do
                                    { codeGeneration result
                                    ; return ()
                                    }
                           }
           Left  err -> do { exitWithError ("Parse error at " ++ show(err)) ParseError
                           ; return ()
                           }
         exitWithSuccess
     else
       if task == Parse then
         do
           let [_, filename] = args
           input <- readFile filename
           let output = runParser pMain 0 "" input
           case output of
             Right ast -> print ast -- print ast
             Left  err -> do { exitWithError ("Parse error at " ++ show(err)) ParseError
                             ; return ()
                             }
       else
         if task == Analyze then
           do
             let [_, filename] = args
             input <- readFile filename
             let output = runParser pMain 0 "" input
             case output of
               Right ast -> do { checkMainProc ast
                               ; let programMap = semanticAnalyse ast
                               ; case programMap of
                                    Left err -> do
                                        { err
                                        ; return ()
                                        }
                                    Right result -> do
                                        { putStrLn $ show result
                                        ; return ()
                                        }
                               }
               Left err -> do { exitWithError ("Parse error at " ++ show(err)) ParseError
                               ; return ()
                               }
         else
           do
             let [_, filename] = args
             input <- readFile filename
             -- let output = ast input
             let output = runParser pMain 0 "" input
             case output of
               Right ast -> prettyPrint ast -- pretty print ast
               Left  err -> do { exitWithError ("Parse error at " ++ show(err)) ParseError
                               ; return ()
                               }
============================================
src/Util.hs
17:43:38_Wednesday_29_May_2019
============================================
module Util where

import qualified Data.Map.Strict as M
import           GoatAST
import           SymbolTable

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the util functions used by multiple modules of the Goat
-- program.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Given the expression table, return the base type.
-------------------------------------------------------------------------------
getExpressionBaseType :: ExpressionTable -> BaseType
getExpressionBaseType exprTable =
  case exprTable of
    VariableTable _ exprType -> exprType
    BoolTable  _             -> BoolType
    IntTable   _             -> IntType
    FloatTable _             -> FloatType
    AddTable   _ _  exprType -> exprType
    SubTable   _ _  exprType -> exprType
    MulTable   _ _  exprType -> exprType
    DivTable   _ _  exprType -> exprType
    OrTable    _ _  exprType -> BoolType
    AndTable   _ _  exprType -> BoolType
    EqTable    _ _  exprType -> BoolType
    NotEqTable _ _  exprType -> BoolType
    LesTable   _ _  exprType -> BoolType
    LesEqTable _ _  exprType -> BoolType
    GrtTable   _ _  exprType -> BoolType
    GrtEqTable _ _  exprType -> BoolType
    NegativeTable _ exprType -> exprType
    NotTable      _ exprType -> BoolType

-------------------------------------------------------------------------------
-- Wrap the provided string with double quotations.
-------------------------------------------------------------------------------
wrapWithDoubleQuotations :: String -> String
wrapWithDoubleQuotations value = "\"" ++ value ++ "\""

-------------------------------------------------------------------------------
-- Get parameters list from the provided parameter map.
-------------------------------------------------------------------------------
paramMapToList :: ParameterMap -> [Parameter]
paramMapToList paramMap = [(snd param) | param <- paramNewList]
  where paramList = M.toList paramMap;
        paramOrderedMap = M.fromList [snd param | param <- paramList]
        paramNewList = M.toList paramOrderedMap
============================================
src/GoatParser.hs
17:43:37_Wednesday_29_May_2019
============================================
module GoatParser where

import           Data.Functor.Identity (Identity)
import           GoatAST
import           GoatConstant
import           Text.Parsec
import           Text.Parsec.Expr
import           Text.Parsec.Language  (emptyDef)
import qualified Text.Parsec.Token     as Q

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the parser-related information of the Goat program.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Define the synonym for of Parser type.
-------------------------------------------------------------------------------
type Parser a = Parsec String Int a

-------------------------------------------------------------------------------
-- lexer definition
-------------------------------------------------------------------------------
lexer :: Q.TokenParser Int
lexer = Q.makeTokenParser (emptyDef { Q.commentLine     = "#"
                                    , Q.nestedComments  = True
                                    , Q.identStart      = letter
                                    , Q.identLetter     = alphaNum
                                                       <|> char '_'
                                                       <|> char '\''
                                    , Q.opStart         = oneOf "+-*/|&!=<>:"
                                    , Q.opLetter        = oneOf "|&="
                                    , Q.reservedNames   = myReservedWords
                                    , Q.reservedOpNames = myOperators
                                    }
                          )

whiteSpace = Q.whiteSpace lexer
lexeme     = Q.lexeme lexer
natural    = Q.natural lexer
float      = Q.float lexer
decimal    = Q.decimal lexer
identifier = Q.identifier lexer
colon      = Q.colon lexer
semi       = Q.semi lexer
comma      = Q.comma lexer
dot        = Q.dot lexer
parens     = Q.parens lexer
brackets   = Q.brackets lexer
reserved   = Q.reserved lexer
reservedOp = Q.reservedOp lexer

-------------------------------------------------------------------------------
-- Define reserved words.
-------------------------------------------------------------------------------
myReservedWords :: [String]
myReservedWords = ["begin", "bool",  "call", "do",  "else",  "end",  "false"
                  ,"fi"   , "float", "if"  , "int", "od",    "proc", "read"
                  ,"ref"  , "then",  "true", "val", "while", "write"]

-------------------------------------------------------------------------------
-- Define reserved operator
-------------------------------------------------------------------------------
myOperators :: [String]
myOperators = [addSymbol, minusSymbol, timesSymbol, lessThanSymbol,
              greaterThanSymbol, lessThanOrEqualSymbol,
              greaterThanOrEqualSymbol, equalSymbol, notEqualSymbol,
              orSymbol, andSymbol ,unaryNotSymbol, divSymbol, ":="]

-------------------------------------------------------------------------------
-- This is the top-most parsing function. It looks for a program which contains
-- one or more procedures.
-------------------------------------------------------------------------------
pProgram :: Parser GoatProgram
pProgram = do
    procedures <- many1 pProcedure
    return (GoatProgram procedures)
    <?> "program procedure"

-------------------------------------------------------------------------------
-- pProcedure looks for a procedure, whose structure should be:
-- "proc" + header + "begin" + body + "end"
-------------------------------------------------------------------------------
pProcedure :: Parser Procedure
pProcedure = do
    reserved "proc"
    header    <- pProcedureHeader
    body      <- pProcedureBody
    return (Procedure header body)
    <?> "procedure"

-------------------------------------------------------------------------------
-- pProcedureHeader looks for the procedure header, which contains a
-- procedure name followed by serveral parameters and variable declarations.
-------------------------------------------------------------------------------
pProcedureHeader :: Parser Header
pProcedureHeader = do
    id     <- identifier
    params <- parens $ sepBy pParameter comma
    return (Header id params)
    <?> "procedure header"

-------------------------------------------------------------------------------
-- pParameter looks for the parameter, which contains an indicator, type of the
-- parameter, and the identifier.
-------------------------------------------------------------------------------
pParameter :: Parser Parameter
pParameter = do
    pIndicator    <-  pParameterIndicator
    parameterType <-  pParameterType
    id            <-  identifier
    return (Parameter pIndicator parameterType id)
    <?> "parameters"


-------------------------------------------------------------------------------
-- pParameterIndicator looks for the indicator of the parameter, and return the
-- corresponding ParameterIndicator type value if it matches the value.
-------------------------------------------------------------------------------
pParameterIndicator :: Parser ParameterIndicator
pParameterIndicator = do { reserved "val"; return VarType }
                      <|>
                      do { reserved "ref"; return RefType }
                      <?> "passing indicator type"


-------------------------------------------------------------------------------
-- pParameterType looks for the base type of the parameter, and return the
-- corresponding BaseType type value if it matches.
-------------------------------------------------------------------------------
pParameterType :: Parser BaseType
pParameterType = do { reserved "bool"; return BoolType }
                 <|>
                 do { reserved "int"; return IntType }
                 <|>
                 do { reserved "float"; return FloatType }
                 <?> "base type indicator"

-------------------------------------------------------------------------------
-- pProcedureBody looks for body, which contains one or more statements.
-------------------------------------------------------------------------------
pProcedureBody :: Parser Body
pProcedureBody = do
    variableDeclarations <- many pVariableDeclaration
    reserved "begin"
    statements           <- many1 pStatement
    reserved "end"
    return (Body variableDeclarations statements)
    <?> "procedure body"

-------------------------------------------------------------------------------
-- pVariableDeclaration looks for the variable declaration, whose pattern
-- should be:
-- variableDeclaration := ParameterType identifier ShapeIndicator
-- If it is found, return a value with VariableDeclaration type.
-------------------------------------------------------------------------------
pVariableDeclaration :: Parser VariableDeclaration
pVariableDeclaration = do
    parameterType  <- pParameterType
    id             <- identifier
    shapeIndicator <- pShapeIndicator
    whiteSpace
    semi
    return (VariableDeclaration parameterType (Variable id shapeIndicator))
    <?> "procedure variable declaration"


-------------------------------------------------------------------------------
-- pShapeIndicator looks for the shape indicator of the variable, whose pattern
-- should be: [m] or [m, n].
-------------------------------------------------------------------------------
pShapeIndicator :: Parser ShapeIndicator
pShapeIndicator =
    try (do { n <- brackets pInt
            ; return (Array n)
            }
        )
    <|>
    try (do { (intM, intN) <- brackets $ pMatrix IntMatrix
            ; return (Matrix intM intN)
            }
        )
    <|>  do { return (NoIndicator) }
    <?> "shape indicator"


-------------------------------------------------------------------------------
-- pMatrix looks for the 2 dimensional matrix
-------------------------------------------------------------------------------
data MatrixType = IntMatrix | ExpressionMatrix
pMatrix :: MatrixType -> Parser (Expression, Expression)
pMatrix IntMatrix = do
    intM <- pInt
    comma
    intN <- pInt
    return (intM, intN)
pMatrix ExpressionMatrix = do
    expressionM <- pExpression
    comma
    expressionN <- pExpression
    return (expressionM, expressionN)

-------------------------------------------------------------------------------
-- Define statement.
-------------------------------------------------------------------------------
pStatement :: Parser Statement
pStatement = choice [pAssignment, pRead, pWrite, pCall, pIf, pWhile]
          <?> "statement"

-------------------------------------------------------------------------------
-- Define the read statement.
-------------------------------------------------------------------------------
pRead :: Parser Statement
pRead = do
    reserved "read"
    id             <- identifier
    shapeIndicator <- pExpressionShapeIndicator
    semi
    return (Read (Variable id shapeIndicator))
    <?> "read statement"

-------------------------------------------------------------------------------
-- Define the write statement.
-------------------------------------------------------------------------------
pWrite :: Parser Statement
pWrite = do
    reserved "write"
    expression <- (pString <|> pExpression)
    whiteSpace
    semi
    return (Write expression)
    <?> "write statement"

-------------------------------------------------------------------------------
-- Define the assignment statement.
-------------------------------------------------------------------------------
pAssignment :: Parser Statement
pAssignment = do
    id  <- identifier
    shapeIndicator <- pExpressionShapeIndicator
    whiteSpace
    reservedOp ":="
    rvalue <- pExpression
    whiteSpace
    semi
    return (Assign (Variable id shapeIndicator) rvalue)
    <?> "Assign statement"

-------------------------------------------------------------------------------
-- Define the call statement.
-------------------------------------------------------------------------------
pCall :: Parser Statement
pCall = do
    reserved "call"
    id      <- identifier
    expressionList <- parens $ sepBy pExpression comma
    whiteSpace
    semi
    return (Call id expressionList)
    <?> "Call statement"

-------------------------------------------------------------------------------
-- Define the if statement.
-------------------------------------------------------------------------------
pIf :: Parser Statement
pIf =
    try(do { reserved "if"
           ; expression <- pExpression
           ; reserved "then"
           ; statements <- many1 pStatement
           ; reserved "fi"
           ; return (If expression statements)
           }
        )
    <|> do { reserved "if"
           ; expression     <- pExpression
           ; reserved "then"
           ; ifStatements   <- many1 pStatement
           ; reserved "else"
           ; elseStatements <- many1 pStatement
           ; reserved "fi"
           ; return (IfElse expression ifStatements elseStatements)
           }
    <?> "If statement"

-------------------------------------------------------------------------------
-- Define the while statement
-------------------------------------------------------------------------------
pWhile :: Parser Statement
pWhile = do
    reserved "while"
    expression <- pExpression
    reserved "do"
    statements <- many1 pStatement
    reserved "od"
    return (While expression statements)
    <?> "While statement"

-------------------------------------------------------------------------------
-- define expressions
-- expression contains operations, relations, expressions, string
-- and boolean
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Define the expression.
-------------------------------------------------------------------------------
pExpression :: Parser Expression
pExpression = buildExpressionParser table pTerm

-------------------------------------------------------------------------------
-- Define the term used in buildExpressionParser.
-------------------------------------------------------------------------------
pTerm :: Parser Expression
pTerm = choice [parens pExpression, pNumber, pIdentifier, pBool]


-------------------------------------------------------------------------------
-- Define the number.
-------------------------------------------------------------------------------
pNumber :: Parser Expression
pNumber = try (do pFloat) <|> do pInt

-------------------------------------------------------------------------------
-- Define the operator precedence table used in buildExpressionParser.
-- The operator in the top of the table has the highest precedence, and the one
-- at the bottom has the lowest precedence.
-------------------------------------------------------------------------------
table :: [[Operator String Int Identity Expression]]
table = [[prefix   minusSymbol UnaryMinus]
        ,[binary   timesSymbol Mul, binary   divSymbol  Div]
        ,[binary   addSymbol Add, binary   minusSymbol  Sub]
        ,[relation equalSymbol Eq,  relation notEqualSymbol NotEq
        , relation lessThanSymbol Les, relation lessThanOrEqualSymbol LesEq
        , relation greaterThanSymbol Grt
        , relation greaterThanOrEqualSymbol GrtEq]
        ,[prefix   unaryNotSymbol UnaryNot]
        ,[binary   andSymbol And]
        ,[binary   orSymbol Or]]

-------------------------------------------------------------------------------
-- Prefix operator
-------------------------------------------------------------------------------
prefix :: String -> (Expression -> Expression)
       -> Operator String Int Identity Expression
prefix name prefixOperator = Prefix (do { reservedOp name;
                                          return prefixOperator
                                        })

-------------------------------------------------------------------------------
-- Binary operator
-------------------------------------------------------------------------------
binary :: String -> (Expression -> Expression -> Expression)
       -> Operator String Int Identity Expression
binary name binaryOperator = Infix (do { reservedOp name;
                                         return binaryOperator
                                       }
                                   ) AssocLeft

-------------------------------------------------------------------------------
-- Relation operator.
-------------------------------------------------------------------------------
relation :: String -> (Expression -> Expression -> Expression)
         -> Operator String Int Identity Expression
relation name relationOperator = Infix (do { reservedOp name;
                                             return relationOperator
                                             }
                                       ) AssocNone

-------------------------------------------------------------------------------
-- Define parser parsing float number.
-------------------------------------------------------------------------------
pFloat :: Parser Expression
pFloat = do { n <- many1 digit;
              char '.';
              m <- many1 digit;
              whiteSpace;
              return (FloatConst (read (n ++ "." ++m) :: Float))
            }
         <?> "float"

-------------------------------------------------------------------------------
-- Define parser parsing integer.
-------------------------------------------------------------------------------
pInt :: Parser Expression
pInt = do { n <- natural;
            return (IntConst (fromInteger n :: Int))
          }
       <?> "integer"

-------------------------------------------------------------------------------
-- Define parser parsing the shape indicator.
-------------------------------------------------------------------------------
pExpressionShapeIndicator :: Parser ShapeIndicator
pExpressionShapeIndicator =
    try (do { expression <- brackets pExpression
            ; return (Array expression)
            }
        )
    <|>
    try (do { (expressionM, expressionN) <- brackets $ pMatrix ExpressionMatrix
            ; return (Matrix expressionM expressionN)
            }
        )
    <|>  do { return (NoIndicator) }

-------------------------------------------------------------------------------
-- Define parser parsing the identifier.
-------------------------------------------------------------------------------
pIdentifier :: Parser Expression
pIdentifier = do
  id             <- identifier
  shapeIndicator <- pExpressionShapeIndicator
  return (ExprVar (Variable id shapeIndicator))
  <?> "identifier"

-------------------------------------------------------------------------------
-- Define parser parsing the string.
-------------------------------------------------------------------------------
pString :: Parser Expression
pString = do
  char '"'
  str <- many (satisfy (/= '"'))
  char '"'
  return (StrConst str)
  <?> "string"

-------------------------------------------------------------------------------
-- Define parser parsing the bool value.
-------------------------------------------------------------------------------
pBool :: Parser Expression
pBool = do {reserved "true"; return (BoolConst True)}
        <|>
        do {reserved "false"; return (BoolConst False)}
        <?> "bool"

-------------------------------------------------------------------------------
-- main function of the parser.
-------------------------------------------------------------------------------
pMain :: Parser GoatProgram
pMain = do
  whiteSpace
  p <- pProgram
  eof
  return p
============================================
src/GoatExit.hs
17:43:37_Wednesday_29_May_2019
============================================
module GoatExit where

import           System.Exit

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the exit-related information of the Goat program,
-- including 2 data types: ExitCode and Task, and 2 functions: exitWithSuccess
-- and exitWithError.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Task type of this Goat compiler.
-------------------------------------------------------------------------------
data Task = Unit | Exit | Compile | Pprint | Analyze | Parse deriving Eq

-------------------------------------------------------------------------------
-- Exit code constant, it starts from 0, increase by 1.
-------------------------------------------------------------------------------
data GoatExitCode = Success          -- 0
                  | MissingFile      -- 1
                  | WrongUsage       -- 2
                  | MissingMain      -- 3
                  | MultipleMain     -- 4
                  | MainWithParam    -- 5
                  | ParseError       -- 6
                  | MultipleProc     -- 7
                  | MultipleVar      -- 8
                  | UndefinedVar     -- 9
                  | ReadIncorrect    -- 10
                  | UnmatchedType    -- 11
                  | IfCondError      -- 12
                  | LogicOpTypeError -- 13
                  | ComparisonError  -- 14
                  | NotSameTypeError -- 15
                  | UnaryMinusError  -- 16
                  | ParamError       -- 17
                  | AssignTypeError  -- 18
                  | VarIndicatorError-- 19
                  | UndefinedProc    -- 20
                  | CallParamNotMatch-- 21
                  deriving Enum

-------------------------------------------------------------------------------
-- Print message to stdout, and exit as successful.
-------------------------------------------------------------------------------
exitWithSuccessWithMessage :: String -> IO ()
exitWithSuccessWithMessage message = do
  putStrLn (message)
  exitWith ExitSuccess

-------------------------------------------------------------------------------
-- Exit as successful without printing message to standard output.
-------------------------------------------------------------------------------
exitWithSuccess :: IO ()
exitWithSuccess = exitWith ExitSuccess


-------------------------------------------------------------------------------
-- Print error message to stderr and exit
-------------------------------------------------------------------------------
exitWithError :: String -> GoatExitCode -> IO Task
exitWithError message exitCode = do
    putStrLn ("[ERROR] " ++ message)
    exitWith (ExitFailure $ fromEnum exitCode)
============================================
src/AnalyzerUtil.hs
17:43:36_Wednesday_29_May_2019
============================================
module AnalyzerUtil where

import qualified Data.Map.Strict as M
import           Data.Maybe
import           GoatAST
import           GoatConstant
import           GoatExit
import           SymbolTable
import           Util

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the analyzer util codes.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------


-------------------------------------------------------------------------------
-- Note: Please filter the StringTable before using this function
--       Cannot be used for String
-- Return the BaseType of given ExpressionTable
-------------------------------------------------------------------------------
getExpressionTableBaseType :: ExpressionTable -> BaseType
getExpressionTableBaseType exprTable =
  case exprTable of
    VariableTable _ exprType -> exprType
    BoolTable  _             -> BoolType
    IntTable   _             -> IntType
    FloatTable _             -> FloatType
    AddTable   _ _  exprType -> exprType
    SubTable   _ _  exprType -> exprType
    MulTable   _ _  exprType -> exprType
    DivTable   _ _  exprType -> exprType
    OrTable    _ _  exprType -> exprType
    AndTable   _ _  exprType -> exprType
    EqTable    _ _  exprType -> exprType
    NotEqTable _ _  exprType -> exprType
    LesTable   _ _  exprType -> exprType
    LesEqTable _ _  exprType -> exprType
    GrtTable   _ _  exprType -> exprType
    GrtEqTable _ _  exprType -> exprType
    NegativeTable _ exprType -> exprType
    NotTable      _ exprType -> exprType

-------------------------------------------------------------------------------
-- Given name of the procedure, which expressions table belongs to, and the
-- left and right expression table, return the expression table's output type.
-------------------------------------------------------------------------------
getExpressionTableType ::
  Identifier -> ExpressionTable -> ExpressionTable -> Either (IO Task) BaseType
getExpressionTableType procName lExprTable rExprTable = do
  case lExprTable of
    IntTable _ -> do
      case rExprTable of
        IntTable _               -> Right IntType
        FloatTable _             -> Right FloatType
        VariableTable _ rVarType -> Right rVarType
        AddTable _ _ rAddType    -> Right rAddType
        SubTable _ _ rSubType    -> Right rSubType
        MulTable _ _ rMulType    -> Right rMulType
        DivTable _ _ rDivType    -> Right rDivType
        NegativeTable _ rVarType -> Right rVarType
        otherwise                -> Left $ exitWithTypeError procName
    FloatTable _ -> Right FloatType
    VariableTable _ lVarType -> getSubExpressionTableType
                                procName
                                lVarType
                                rExprTable
    AddTable    _ _ lAddType -> getSubExpressionTableType
                                procName
                                lAddType
                                rExprTable
    SubTable    _ _ lSubType -> getSubExpressionTableType
                                procName
                                lSubType
                                rExprTable
    MulTable    _ _ lMulType -> getSubExpressionTableType
                                procName
                                lMulType
                                rExprTable
    DivTable    _ _ lDivType -> getSubExpressionTableType
                                procName
                                lDivType
                                rExprTable
    NegativeTable _ lVarType -> getSubExpressionTableType
                                procName
                                lVarType
                                rExprTable
    otherwise                -> Left $ exitWithTypeError procName

-------------------------------------------------------------------------------
-- Given the base type and expression table, return the expression table's
-- output type.
-------------------------------------------------------------------------------
getSubExpressionTableType ::
  Identifier -> BaseType -> ExpressionTable -> Either (IO Task) BaseType
getSubExpressionTableType procName baseType expressionTable = do
  case expressionTable of
    IntTable _               -> Right baseType
    FloatTable _             -> Right FloatType
    VariableTable _ rVarType -> chooseType procName baseType rVarType
    AddTable _ _ rAddType    -> chooseType procName baseType rAddType
    SubTable _ _ rSubType    -> chooseType procName baseType rSubType
    MulTable _ _ rMulType    -> chooseType procName baseType rMulType
    DivTable _ _ rDivType    -> chooseType procName baseType rDivType
    NegativeTable _ rVarType -> chooseType procName baseType rVarType
    otherwise                -> Left $ exitWithTypeError procName

-------------------------------------------------------------------------------
-- Check if there is bool type found, if so, exit with type error message,
-- otherwise return the proper base type.
-------------------------------------------------------------------------------
chooseType :: Identifier -> BaseType -> BaseType -> Either (IO Task) BaseType
chooseType _ IntType IntType   = Right IntType
chooseType _ FloatType _       = Right FloatType
chooseType _ _ FloatType       = Right FloatType
chooseType procName BoolType _ = Left $ exitWithTypeError procName
chooseType procName _ BoolType = Left $ exitWithTypeError procName

-------------------------------------------------------------------------------
-- lookup parameter Map, It must have a base type
-------------------------------------------------------------------------------
lookupBaseTypeParamMap ::
  Identifier -> M.Map Identifier (Int, Parameter) -> BaseType
lookupBaseTypeParamMap varName paramMap =
    case M.lookup varName paramMap of
      Just parameter -> passingType (snd parameter)

-------------------------------------------------------------------------------
-- lookup variable Map, It must have a base type
-------------------------------------------------------------------------------
lookupBaseTypeVarMap ::
  Identifier -> M.Map Identifier VariableDeclaration -> BaseType
lookupBaseTypeVarMap varName varMap =
      case M.lookup varName varMap of
        Just variable -> declarationType variable

-------------------------------------------------------------------------------
-- Get procedure identifier from procedure.
-------------------------------------------------------------------------------
getProcedureIdentifier :: Procedure -> Identifier
getProcedureIdentifier = headerIdent . header

-------------------------------------------------------------------------------
-- Get parameters list from procedure.
-------------------------------------------------------------------------------
getProcedureParameters :: Procedure -> [Parameter]
getProcedureParameters = parameters . header

-------------------------------------------------------------------------------
-- Get the error message for multiple declarations for one variable.
-------------------------------------------------------------------------------
getMultipleVarDeclarationErrorMessage :: Identifier -> Identifier -> String
getMultipleVarDeclarationErrorMessage varName procName =
  "There are multiple variable declaration named " ++
  (wrapWithDoubleQuotations varName) ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message indicating multiple declaration for one
-- variable.
-------------------------------------------------------------------------------
exitWithMultipleVarDeclaration :: Identifier -> Identifier -> IO Task
exitWithMultipleVarDeclaration varName procName =
  exitWithError
  (getMultipleVarDeclarationErrorMessage varName procName)
  MultipleVar

-------------------------------------------------------------------------------
-- Get the error message for condition type error.
-------------------------------------------------------------------------------
getConditionTypeErrorMessage :: Identifier -> String
getConditionTypeErrorMessage procName =
  "If condition type error! The type must be bool. In procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message indicating condition type error.
-------------------------------------------------------------------------------
exitWithConditionTypeError :: Identifier -> IO Task
exitWithConditionTypeError procName =
  exitWithError
  (getConditionTypeErrorMessage procName)
  IfCondError

-------------------------------------------------------------------------------
-- Get the error message for logic type error.
-------------------------------------------------------------------------------
getLogicExprTypeErrorMessage :: Identifier -> String -> String
getLogicExprTypeErrorMessage procName operator =
  operatorWithQuotationMarks ++
  " type error! The argument of " ++
  operatorWithQuotationMarks ++
  " must be bool. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where operatorWithQuotationMarks = wrapWithDoubleQuotations operator

-------------------------------------------------------------------------------
-- Exit the program with error message indicating logic type error.
-------------------------------------------------------------------------------
exitWithLogicExprTypeError :: Identifier -> String -> IO Task
exitWithLogicExprTypeError procName operator =
  exitWithError
  (getLogicExprTypeErrorMessage procName operator)
  LogicOpTypeError

-------------------------------------------------------------------------------
-- Get the error message for variable undefined error.
-------------------------------------------------------------------------------
getUndefinedVariableErrorMessage :: Identifier -> String
getUndefinedVariableErrorMessage varName =
  "There is a undefined variable named " ++
  (wrapWithDoubleQuotations varName) ++
  " in the statement"

-------------------------------------------------------------------------------
-- Exit the program with error message of undefined variable error.
-------------------------------------------------------------------------------
exitWithUndefinedVariable :: Identifier -> IO Task
exitWithUndefinedVariable varName =
  exitWithError
  (getUndefinedVariableErrorMessage varName)
  UndefinedVar

-------------------------------------------------------------------------------
-- Exit the program with error message of read statement with
-- non-variable expression
-------------------------------------------------------------------------------
exitWithReadIncorrect :: IO Task
exitWithReadIncorrect =
  exitWithError "Cannot read into non-variable" ReadIncorrect

-------------------------------------------------------------------------------
-- Exit the program with error message of unmatched variable type error.
-------------------------------------------------------------------------------
exitWithTypeError :: Identifier -> IO Task
exitWithTypeError procName =
  exitWithError ("There is a Type Error in the Statment in proc: " ++
                (wrapWithDoubleQuotations procName)) UnmatchedType

-------------------------------------------------------------------------------
-- Get the error message for procedure not found error.
-------------------------------------------------------------------------------
getProcNotFoundMessage :: Identifier -> String -> String
getProcNotFoundMessage procName calledProcName =
  "Call Statement Error! Called Procedure " ++
  (wrapWithDoubleQuotations calledProcName) ++
  " is not found in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of procedure not found error.
-------------------------------------------------------------------------------
exitWithProcNotFound :: Identifier -> String -> IO Task
exitWithProcNotFound procName calledProcName =
  exitWithError
  (getProcNotFoundMessage procName calledProcName)
  UndefinedProc

-------------------------------------------------------------------------------
-- Get the error message for called procedure name unmatched error.
-------------------------------------------------------------------------------
getCallParamLengthDiffMessage :: Identifier -> String -> String
getCallParamLengthDiffMessage procName calledProcId =
  "Call Statement Error! The parameter of called procedure " ++
  (wrapWithDoubleQuotations calledProcId) ++
  " does not match the declaration in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of called procedure name unmatched error.
-------------------------------------------------------------------------------
exitWithCallParamLengthDiff :: Identifier -> String -> IO Task
exitWithCallParamLengthDiff procName calledProcId =
  exitWithError
  (getCallParamLengthDiffMessage procName calledProcId)
  CallParamNotMatch

-------------------------------------------------------------------------------
-- Get the error message for type error in comparision.
-------------------------------------------------------------------------------
getComparisonExprTypeErrorMessage :: Identifier -> String -> String
getComparisonExprTypeErrorMessage procName operator =
  operatorWithQuotationMarks ++
  " type error! The argument of " ++
  operatorWithQuotationMarks ++
  " must be base type. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where operatorWithQuotationMarks = wrapWithDoubleQuotations operator

-------------------------------------------------------------------------------
-- Exit the program with error message of type error in comparision.
-------------------------------------------------------------------------------
exitWithComparisonTypeError :: Identifier -> String -> IO Task
exitWithComparisonTypeError procName operator =
  exitWithError
  (getComparisonExprTypeErrorMessage procName operator)
  ComparisonError

-------------------------------------------------------------------------------
-- Get the error message for different type error.
-------------------------------------------------------------------------------
getNotSameTypeErrorMessage :: Identifier -> String -> String
getNotSameTypeErrorMessage procName operator =
  operatorWithQuotationMarks ++
  " type error! The argument of " ++
  operatorWithQuotationMarks ++
  " must be same base type. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where operatorWithQuotationMarks = wrapWithDoubleQuotations operator

-------------------------------------------------------------------------------
-- Exit the program with error message of different type error.
-------------------------------------------------------------------------------
exitWithNotSameTypeError :: Identifier -> String -> IO Task
exitWithNotSameTypeError procName operator =
  exitWithError
  (getNotSameTypeErrorMessage procName operator)
  NotSameTypeError

-------------------------------------------------------------------------------
-- Get the error message for Unary Minus type error.
-------------------------------------------------------------------------------
getUnaryMinusTypeErrorMessage :: Identifier -> String
getUnaryMinusTypeErrorMessage procName =
  unaryMinusString ++
  " type error! The argument of " ++
  unaryMinusString ++
  " must be int or float. In procedure " ++
  (wrapWithDoubleQuotations procName)
  where unaryMinusString = "\"-\" (Unary Minus)"

-------------------------------------------------------------------------------
-- Exit the program with error message of Unary Minus type error.
-------------------------------------------------------------------------------
exitWithUnaryMinusError :: Identifier -> IO Task
exitWithUnaryMinusError procName =
  exitWithError
  (getUnaryMinusTypeErrorMessage procName)
  UnaryMinusError

-------------------------------------------------------------------------------
-- Get the error message for type error in Assignment.
-------------------------------------------------------------------------------
getAssignTypeErrorMessage :: Identifier -> String -> String
getAssignTypeErrorMessage procName varName =
  "Assign Type Error! The type of " ++
  (wrapWithDoubleQuotations varName) ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName) ++
  " is not match."

-------------------------------------------------------------------------------
-- Exit the program with error message of type error in Assignment.
-------------------------------------------------------------------------------
exitWithAssignTypeError :: Identifier -> String -> IO Task
exitWithAssignTypeError procName varName =
  exitWithError
  (getAssignTypeErrorMessage procName varName)
  AssignTypeError

-------------------------------------------------------------------------------
-- Get the error message for variable indicator not match error.
-------------------------------------------------------------------------------
getVarIndicatorErrorMessage :: Identifier -> String -> String
getVarIndicatorErrorMessage procName varName =
  "Variable indicator Error! The variable " ++
  (wrapWithDoubleQuotations varName) ++
  " should not be Array or Matrix in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of variable indicator not match error.
-------------------------------------------------------------------------------
exitWithVarIndicatorError :: Identifier -> String -> IO Task
exitWithVarIndicatorError procName varName =
  exitWithError
  (getVarIndicatorErrorMessage procName varName)
  VarIndicatorError

-------------------------------------------------------------------------------
-- Get the error message for variable indicator type unmatched error.
-------------------------------------------------------------------------------
getVarIndicatorNotSameMessage :: Identifier -> String -> String
getVarIndicatorNotSameMessage procName varName =
  "Variable indicator Error! The indicator of variable " ++
  (wrapWithDoubleQuotations varName) ++
  " is not same as declaration" ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of variable
-- indicator type unmatched error.
-------------------------------------------------------------------------------
exitWithVarIndicatorNotSame :: Identifier -> String -> IO Task
exitWithVarIndicatorNotSame procName varName =
  exitWithError
  (getVarIndicatorNotSameMessage procName varName)
  VarIndicatorError

-------------------------------------------------------------------------------
-- Get the error message for array and matrix base type error.
-------------------------------------------------------------------------------
getArrayMatrixIndicatorTypeErrorMessage :: Identifier -> String -> String
getArrayMatrixIndicatorTypeErrorMessage procName varName =
  "Array and Matrix dimension type Error! The dimension of Array and Matrix" ++
  " must be Int. For variable  "++
  (wrapWithDoubleQuotations varName) ++
  " in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of array and matrix base type error.
-------------------------------------------------------------------------------
exitArrayMatrixDimensionTypeError :: Identifier -> String -> IO Task
exitArrayMatrixDimensionTypeError procName varName =
  exitWithError
  (getArrayMatrixIndicatorTypeErrorMessage procName varName)
  VarIndicatorError

-------------------------------------------------------------------------------
-- Get the error message for duplicate procedure names error.
-------------------------------------------------------------------------------
getDuplicateProcedureErrorMessage :: Identifier -> String
getDuplicateProcedureErrorMessage procName =
  "There are multiple procedures named " ++ (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of duplicate procedure names error.
-------------------------------------------------------------------------------
exitWithDuplicateProcedure :: Identifier -> IO Task
exitWithDuplicateProcedure procName =
  exitWithError
  (getDuplicateProcedureErrorMessage procName)
  MultipleProc

-------------------------------------------------------------------------------
-- Get the error message for call expression invalid error.
-------------------------------------------------------------------------------
getInvalidCallExprMessage :: Identifier -> Identifier -> String
getInvalidCallExprMessage procName calledProcId =
  "Invalid Call statement arguments! The argument of call statement for " ++
  "procedure " ++
  (wrapWithDoubleQuotations calledProcId) ++
  " should only be variable in procedure " ++
  (wrapWithDoubleQuotations procName)

-------------------------------------------------------------------------------
-- Exit the program with error message of call expression invalid error.
-------------------------------------------------------------------------------
exitWithInvalidCallExpr :: Identifier -> Identifier -> IO Task
exitWithInvalidCallExpr procName calledProcId =
  exitWithError
  (getInvalidCallExprMessage procName calledProcId)
  MultipleProc
============================================
src/GoatConstant.hs
17:43:37_Wednesday_29_May_2019
============================================
module GoatConstant where


-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the commonly used constants.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

--------------------------- Algorithmetic symbols -----------------------------
addSymbol :: String
addSymbol =  "+"

minusSymbol :: String
minusSymbol = "-"

timesSymbol :: String
timesSymbol = "*"

divSymbol :: String
divSymbol = "/"
--------------------------- Algorithmetic symbols -----------------------------

----------------------------- Comparison symbols ------------------------------
equalSymbol :: String
equalSymbol = "="

notEqualSymbol :: String
notEqualSymbol = "!="

lessThanSymbol :: String
lessThanSymbol = "<"

lessThanOrEqualSymbol :: String
lessThanOrEqualSymbol = "<="

greaterThanSymbol :: String
greaterThanSymbol = ">"

greaterThanOrEqualSymbol :: String
greaterThanOrEqualSymbol = ">="
----------------------------- Comparison symbols ------------------------------

unaryNotSymbol :: String
unaryNotSymbol = "!"

orSymbol :: String
orSymbol = "||"

andSymbol :: String
andSymbol = "&&"
============================================
src/CodeGenerator.hs
17:43:36_Wednesday_29_May_2019
============================================
module CodeGenerator where

import           Analyzer
import           Control.Monad.State
import qualified Data.Map.Strict     as Map
import           GoatAST
import           GoatExit
import           GoatPrettyPrint
import           SymbolTable
import           Util

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the code generator of the Goat program.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Alias for register.
-------------------------------------------------------------------------------
type Register = String

-------------------------------------------------------------------------------
-- Alias for slot number.
-------------------------------------------------------------------------------
type SlotNumber = Int

-------------------------------------------------------------------------------
-- Acceptable input value
-------------------------------------------------------------------------------
data InputValue = Int | Float | String

-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- The entry point for the code generation pipeline.
-------------------------------------------------------------------------------
codeGeneration :: ProgramMap -> IO ()
codeGeneration programMap = do { printLine "call proc_main"
                               ; printLine "halt"
                               ; let procedures = Map.keys programMap
                               ; generateProcedureList procedures programMap
                               }

-------------------------------------------------------------------------------
-- Generate a sequence of procedures from a list of procedure names.
-------------------------------------------------------------------------------
generateProcedureList :: [String] -> ProgramMap -> IO ()
generateProcedureList (procedure:[]) programMap =
    case Map.lookup procedure programMap of
        Just procedureTable -> do { putStrLn $ "proc_" ++ procedure ++ ":"
                                  ; generateProcedure procedure procedureTable
                                  ; printLine "return"
                                  }
generateProcedureList (procedure:procedures) programMap =
    case Map.lookup procedure programMap of
        Just procedureTable -> do { putStrLn $ "proc_" ++ procedure ++ ":"
                                  ; generateProcedure procedure procedureTable
                                  ; printLine "return"
                                  ; generateProcedureList procedures programMap
                                  }

-------------------------------------------------------------------------------
-- Generate an individual procedure for a given procedure name and the
-- corresponding PrecedureTable.
-------------------------------------------------------------------------------
generateProcedure :: Identifier -> ProcedureTable -> IO ()
generateProcedure procName (ProcedureTable paramMap varMap statements) = do
    let parameterNumber = Map.size paramMap
        varList         = Map.keys varMap
        variableNumber  = getVariableMapSize varList varMap
        totalVarNumber  = parameterNumber + variableNumber
    case totalVarNumber of
        0         -> putStr ""
        otherwise -> printLine $ "push_stack_frame " ++ (show totalVarNumber)
    let stackMap = insertStackMap paramMap varMap
        paramList = paramMapToList paramMap
    case parameterNumber of
        0         -> putStr ""
        otherwise -> do { printComment "init parameters"
                        ; initParameters paramList stackMap 0
                        }
    case variableNumber of
        0         -> putStr ""
        otherwise -> do { printComment "init variables"
                        ; initVariables varList varMap stackMap
                        }
    generateStatements procName [0] paramMap varMap statements stackMap
    case totalVarNumber of
        0         -> putStr ""
        otherwise -> printLine $ "pop_stack_frame " ++ (show totalVarNumber)

-------------------------------------------------------------------------------
-- Generate oz code for initializing a list of parameters.
-------------------------------------------------------------------------------
initParameters :: [Parameter] -> StackMap -> Int -> IO ()
initParameters [] _ _ = return ()
initParameters (param:[]) stackMap registerNum = do
  let paramSlotNum = stackMap Map.! paramName
      paramName = passingIdent param
  printComment $ "initialise parameters " ++ paramName
  printLine $ "store " ++ (show paramSlotNum) ++ ", r" ++ (show registerNum)

initParameters (param:params) stackMap registerNum = do
  let paramSlotNum = stackMap Map.! paramName
      paramName = passingIdent param
  printComment $ "initialise parameters " ++ paramName
  printLine $ "store " ++ (show paramSlotNum) ++ ", r" ++ (show registerNum)
  initParameters params stackMap (registerNum + 1)

-------------------------------------------------------------------------------
-- Generate oz code for initializing a list of variables.
-------------------------------------------------------------------------------
initVariables :: [Identifier] -> VariableMap -> StackMap -> IO ()
initVariables [] _ _ = return ()
initVariables (var:[]) varMap stackMap = do
  let varType    = declarationType $ varMap Map.! var
      varSlotNum   = stackMap Map.! var
      varIndicator = varShapeIndicator $ declarationVariable (varMap Map.! var)
  printComment $ "initialise variable " ++ var
  initVariableByBaseType varType
  initVariableWithIndicator varIndicator varSlotNum
initVariables (var:varList) varMap stackMap = do
  let varType    = declarationType $ varMap Map.! var
      varSlotNum = stackMap Map.! var
      varIndicator = varShapeIndicator $ declarationVariable (varMap Map.! var)
  printComment $ "init variable: " ++ var
  initVariableByBaseType varType
  initVariableWithIndicator varIndicator varSlotNum
  initVariables varList varMap stackMap

-------------------------------------------------------------------------------
-- Generate oz code for initialize a variable based on its base type, which
-- can be either float or int.
-------------------------------------------------------------------------------
initVariableByBaseType :: BaseType -> IO ()
initVariableByBaseType baseType =
  case baseType of
    FloatType -> printLine "real_const r0, 0.0"
    otherwise -> printLine "int_const r0, 0"

-------------------------------------------------------------------------------
-- Generate os code for initializing a variable that's either an array,
-- a matrix, or a value.
-------------------------------------------------------------------------------
initVariableWithIndicator :: ShapeIndicator -> Int -> IO ()
initVariableWithIndicator varIndicator varSlotNum = do
  case varIndicator of
    NoIndicator                      -> initSingleVar varSlotNum
    Array  (IntConst n)              -> initOffset    varSlotNum n
    Matrix (IntConst m) (IntConst n) -> initOffset    varSlotNum (m*n)

-------------------------------------------------------------------------------
-- Initialize a single value variable
-------------------------------------------------------------------------------
initSingleVar :: Int -> IO ()
initSingleVar varSlotNum = printLine $ "store " ++ (show varSlotNum) ++ ", r0"

-------------------------------------------------------------------------------
-- Helper function for initializing array or matrix.
-------------------------------------------------------------------------------
initOffset :: Int -> Int -> IO ()
initOffset varSlotNum offset = do
  if offset > 0
    then do { initSingleVar varSlotNum
            ; initOffset (varSlotNum+1) (offset-1)
            }
    else putStr ""

-------------------------------------------------------------------------------
-- Generate oz code for a set of statements, given the list of StatementTables.
-------------------------------------------------------------------------------
generateStatements :: String -> [Int] -> ParameterMap -> VariableMap -> [StatementTable] -> StackMap -> IO ()
generateStatements _ _ _ _ [] _  = return ()
generateStatements procName label paramMap varMap (stat:[]) stackMap = do
    generateStatement procName (updateLabel label) paramMap varMap stat stackMap
generateStatements procName label paramMap varMap (stat:stats) stackMap = do
    { generateStatement procName (updateLabel label) paramMap varMap stat stackMap
    ; generateStatements procName (updateLabel label) paramMap varMap stats stackMap
    }

-------------------------------------------------------------------------------
-- Generate oz code for a single statement.
-------------------------------------------------------------------------------
generateStatement :: String -> [Int] -> ParameterMap -> VariableMap -> StatementTable -> StackMap -> IO ()
generateStatement procName label paramMap varMap statementTable stackMap = do
  case statementTable of
    AssignTable varTable  exprTable  ->
      generateAssignStatement procName paramMap varMap varTable exprTable stackMap
    WriteTable  exprTable            -> generateWriteStatement paramMap varMap exprTable stackMap
    IfTable     exprTable stmtTables ->
      generateIfStatement procName label exprTable paramMap varMap stmtTables stackMap
    IfElseTable exprTable stmtTables1 stmtTables2 ->
      generateIfElseStatement procName label exprTable paramMap varMap stmtTables1 stmtTables2 stackMap
    WhileTable  exprTable stmtTables ->
      generateWhileStatement procName label exprTable paramMap varMap stmtTables stackMap
    ReadTable exprTable ->
      generateReadStatement exprTable paramMap varMap stackMap
    CallTable procId expressionTables params ->
        generateCallStatement procId expressionTables params 0 paramMap varMap stackMap

-------------------------------------------------------------------------------
-- Genearate oz code for a procedure call statement.
-------------------------------------------------------------------------------
generateCallStatement :: Identifier -> [ExpressionTable] -> [Parameter] -> Int -> ParameterMap -> VariableMap -> StackMap -> IO ()
generateCallStatement procName [] [] _ _ _ _ = printLine $ "call proc_" ++ procName
generateCallStatement procName (exprTable:[]) (param:[]) registerNum paramMap varMap stackMap = do
  checkCallParameter param exprTable registerNum paramMap varMap stackMap
  -- print call statement after all parameters are loaded into registers.
  printLine $ "call proc_" ++ procName

generateCallStatement procName (exprTable:exprTables) (param:params) registerNum paramMap varMap stackMap = do
  checkCallParameter param exprTable registerNum paramMap varMap stackMap
  generateCallStatement procName exprTables params (registerNum+1) paramMap varMap stackMap

checkCallParameter :: Parameter -> ExpressionTable -> Int -> ParameterMap -> VariableMap -> StackMap -> IO ()
checkCallParameter param exprTable registerNum paramMap varMap stackMap = do
  let  varType   = getExpressionBaseType exprTable
       paramType = passingType param
       paramIndicator = passingIndicator param
  case paramIndicator of
    VarType -> do
      generateExpression paramMap varMap exprTable registerNum stackMap
      if (FloatType == paramType) && (IntType == varType)
        then printIntToRealInSameRegister 0
        else putStr ""
    RefType -> do
      let var = variable exprTable
          paramId = varName var
          slotNum = stackMap Map.! paramId
          slotNumStr = show slotNum
          regNumStr0 = "r" ++ (show registerNum)
      case (Map.member paramId paramMap) of
        False -> do
          let  varShape = varShapeIndicatorTable var
          case varShape of
            NoIndicatorTable ->
              printLine $ "load_address " ++ regNumStr0 ++ ", " ++ slotNumStr
            otherwise        -> do
              locateArrayMatrix paramMap varMap var slotNumStr registerNum stackMap
        True -> do
          let parameter = snd $ paramMap Map.! paramId
              passType  = passingIndicator parameter
          case passType of
            VarType -> printLine $ "load_address " ++ regNumStr0 ++ ", " ++ slotNumStr
            RefType -> printLine $ "load " ++ regNumStr0 ++ ", " ++ slotNumStr

-------------------------------------------------------------------------------
-- Generate oz code for an assignment statement.
-------------------------------------------------------------------------------
generateAssignStatement ::
  String -> ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> StackMap -> IO ()
generateAssignStatement procName paramMap varMap varTable exprTable stackMap = do
  { let var     = variable varTable
        varType = variableType varTable
        varId   = varName  var
        exprType = getExpressionBaseType exprTable
        varShape = varShapeIndicatorTable var
        varSlotNum = getVariableSlotNum var stackMap
        varSlotNumStr = show varSlotNum
  ; printComment $ "Assign statement for variable " ++ varId
  -- Right expression
  ; generateExpression paramMap varMap exprTable 0 stackMap
  ; if (FloatType == varType) && (IntType == exprType)
        then printIntToRealInSameRegister 0
        else putStr ""
  -- Left Variable
  ; case (Map.member varId paramMap) of
      False -> do
        { case varShape of
            NoIndicatorTable ->
              printLine $ "store " ++ varSlotNumStr ++ ", r0"
            otherwise        -> do
              { locateArrayMatrix paramMap varMap var varSlotNumStr 1 stackMap
              ; printLine $ "store_indirect r1, r0"
              }
        }
      True -> do
        let parameter = snd $ paramMap Map.! varId
            passType  = passingIndicator parameter
        case passType of
          VarType -> printLine $ "store " ++ varSlotNumStr ++ ", r0"
          RefType -> do
            { printLine $ "load r1, " ++ varSlotNumStr
            ; printLine $ "store_indirect r1, r0"
            }
  }

-------------------------------------------------------------------------------
-- Generate oz code for a write statement.
-------------------------------------------------------------------------------
generateWriteStatement :: ParameterMap -> VariableMap -> ExpressionTable -> StackMap -> IO ()
generateWriteStatement paramMap varMap exprTable stackMap =
    case exprTable of
        VariableTable _ exprType ->
            generateWriteChooseType exprType paramMap varMap exprTable stackMap
        BoolTable   _ -> generateWriteWithType "bool"    paramMap varMap exprTable stackMap
        IntTable    _ -> generateWriteWithType "int"    paramMap varMap exprTable stackMap
        FloatTable  _ -> generateWriteWithType "real"   paramMap varMap exprTable stackMap
        StringTable _ -> generateWriteWithType "string" paramMap varMap exprTable stackMap
        AddTable    _ _ exprType ->
            generateWriteChooseType exprType paramMap varMap exprTable stackMap
        SubTable    _ _ exprType ->
            generateWriteChooseType exprType paramMap varMap exprTable stackMap
        MulTable    _ _ exprType ->
            generateWriteChooseType exprType paramMap varMap exprTable stackMap
        DivTable    _ _ exprType ->
            generateWriteChooseType exprType paramMap varMap exprTable stackMap
        NegativeTable _ exprType ->
            generateWriteChooseType exprType paramMap varMap exprTable stackMap
        otherwise -> generateWriteWithType "bool" paramMap varMap exprTable stackMap

-------------------------------------------------------------------------------
-- Generate oz code for a write statement of a given type as a string.
-------------------------------------------------------------------------------
generateWriteWithType :: String -> ParameterMap -> VariableMap -> ExpressionTable -> StackMap -> IO ()
generateWriteWithType writeType paramMap varMap exprTable stackMap = do
  { generateExpression paramMap varMap exprTable 0 stackMap
  ; printLine $ "call_builtin print_" ++ writeType
  }

-------------------------------------------------------------------------------
-- Generate oz code for a write statement of a given base type.
-------------------------------------------------------------------------------
generateWriteChooseType :: BaseType -> ParameterMap -> VariableMap -> ExpressionTable -> StackMap -> IO ()
generateWriteChooseType exprType paramMap varMap exprTable stackMap =
  case exprType of
    IntType   -> generateWriteWithType "int" paramMap  varMap exprTable stackMap
    FloatType -> generateWriteWithType "real" paramMap varMap exprTable stackMap
    BoolType  -> generateWriteWithType "bool" paramMap varMap exprTable stackMap

-------------------------------------------------------------------------------
-- Generate oz code for a read statement.
-------------------------------------------------------------------------------
generateReadStatement :: ExpressionTable -> ParameterMap -> VariableMap -> StackMap -> IO ()
generateReadStatement exprTable paramMap varMap stackMap = do
    let exprType = getExpressionBaseType exprTable
        slotNum = stackMap Map.! (varName $ variable exprTable)
    case exprType of
        BoolType  -> generateReadStatementByType "bool" slotNum exprTable paramMap varMap stackMap
        IntType   -> generateReadStatementByType "int"  slotNum exprTable paramMap varMap stackMap
        FloatType -> generateReadStatementByType "real" slotNum exprTable paramMap varMap stackMap

-------------------------------------------------------------------------------
-- Generate oz code for a read statement of a given base type.
-------------------------------------------------------------------------------
generateReadStatementByType :: String -> Int -> ExpressionTable -> ParameterMap -> VariableMap -> StackMap -> IO ()
generateReadStatementByType baseType slotNum exprTable paramMap varMap stackMap = do
  case exprTable of
    VariableTable var varType -> do
      let varId   = varName  var
          varShape = varShapeIndicatorTable var
          varSlotNum = getVariableSlotNum var stackMap
          varSlotNumStr = show varSlotNum
      printLine ("call_builtin read_" ++ baseType)
      case (Map.member varId paramMap) of
        False -> do
          { case varShape of
              NoIndicatorTable ->
                printLine $ "store " ++ varSlotNumStr ++ ", r0"
              otherwise        -> do
                { locateArrayMatrix paramMap varMap var varSlotNumStr 1 stackMap
                ; printLine $ "store_indirect r1, r0"
                }
          }
        True -> do
          let parameter = snd $ paramMap Map.! varId
              passType  = passingIndicator parameter
          case passType of
            VarType -> printLine $ "store " ++ varSlotNumStr ++ ", r0"
            RefType -> do
              { printLine $ "load r1, " ++ varSlotNumStr
              ; printLine $ "store_indirect r1, r0"
              }

-------------------------------------------------------------------------------
-- Generate oz code for an expression, given its ExpressionTable.
-------------------------------------------------------------------------------
generateExpression :: ParameterMap -> VariableMap -> ExpressionTable -> Int -> StackMap -> IO ()
generateExpression paramMap varMap exprTable registerNum stackMap =
    case exprTable of
        VariableTable var varType ->
          generateVariableExpr paramMap varMap var varType registerNum stackMap
        BoolTable val -> printLine ("int_const r" ++ (show registerNum) ++
                                    ", " ++ (convertBoolToInt val))
        IntTable val -> do { printNewLineIndentation
                           ; putStrLn $ "int_const r" ++ (show registerNum)
                             ++ ", " ++ (show val)
                           }
        FloatTable val -> do { printNewLineIndentation
                             ; putStrLn $ "real_const r" ++ (show registerNum)
                               ++ ", " ++ (show val)
                             }
        StringTable val -> printLine ("string_const r" ++ (show registerNum) ++
                                      ", " ++ (wrapWithDoubleQuotations val))
        AddTable lExpr rExpr baseType -> do
              generateExpression paramMap varMap lExpr registerNum stackMap
              generateExpression paramMap varMap rExpr (registerNum+1) stackMap
              case baseType of
                   IntType -> do { generateOperationString "add" "int" registerNum }
                   FloatType -> do { generateIntToFloat lExpr rExpr registerNum
                                   ; generateOperationString "add" "real" registerNum
                                   }
        SubTable lExpr rExpr baseType -> do
              generateExpression paramMap varMap lExpr registerNum stackMap
              generateExpression paramMap varMap rExpr (registerNum+1) stackMap
              case baseType of
                   IntType -> do { generateOperationString "sub" "int" registerNum }
                   FloatType -> do { generateIntToFloat lExpr rExpr registerNum
                                   ; generateOperationString "sub" "real" registerNum
                                   }
        MulTable lExpr rExpr baseType -> do
              generateExpression paramMap varMap lExpr registerNum stackMap
              generateExpression paramMap varMap rExpr (registerNum+1) stackMap
              case baseType of
                   IntType -> do { generateOperationString "mul" "int" registerNum }
                   FloatType -> do { generateIntToFloat lExpr rExpr registerNum
                                   ; generateOperationString "mul" "real" registerNum
                                   }
        DivTable lExpr rExpr baseType -> do
              generateExpression paramMap varMap lExpr registerNum stackMap
              generateExpression paramMap varMap rExpr (registerNum+1) stackMap
              case baseType of
                   IntType -> do { generateOperationString "div" "int" registerNum }
                   FloatType -> do { generateIntToFloat lExpr rExpr registerNum
                                   ; generateOperationString "div" "real" registerNum
                                   }
        OrTable    lExpr rExpr _        -> generateOrExpression    paramMap varMap lExpr rExpr registerNum stackMap
        AndTable   lExpr rExpr _        -> generateAndExpression   paramMap varMap lExpr rExpr registerNum stackMap
        EqTable    lExpr rExpr exprType -> generateEqExpression    paramMap varMap lExpr rExpr registerNum exprType stackMap
        NotEqTable lExpr rExpr exprType -> generateNotEqExpression paramMap varMap lExpr rExpr registerNum exprType stackMap
        LesTable   lExpr rExpr exprType -> generateLesExpression   paramMap varMap lExpr rExpr registerNum exprType stackMap
        LesEqTable lExpr rExpr exprType -> generateLesEqExpression paramMap varMap lExpr rExpr registerNum exprType stackMap
        GrtTable   lExpr rExpr exprType -> generateGrtExpression   paramMap varMap lExpr rExpr registerNum exprType stackMap
        GrtEqTable lExpr rExpr exprType -> generateGrtEqExpression paramMap varMap lExpr rExpr registerNum exprType stackMap
        NegativeTable     expr exprType -> generateNegativeExpression paramMap varMap expr registerNum exprType stackMap
        NotTable   expr  _ -> generateNotExpression paramMap varMap expr registerNum stackMap

-------------------------------------------------------------------------------
-- Update labels for statement generation.
-------------------------------------------------------------------------------
updateLabel :: [Int] -> [Int]
updateLabel (x:[]) = (x+1):[]
updateLabel (x:xs) = x:(updateLabel xs)

-------------------------------------------------------------------------------
-- Helper function to print labels for conditional statements.
-------------------------------------------------------------------------------
showLabel :: [Int] -> String
showLabel (x:[]) = show(x)
showLabel (x:xs) = show(x) ++ "_" ++ showLabel(xs)

-------------------------------------------------------------------------------
-- Generate oz code for an if statement.
-------------------------------------------------------------------------------
generateIfStatement ::
  String -> [Int] -> ExpressionTable -> ParameterMap -> VariableMap -> [StatementTable] -> StackMap -> IO ()
generateIfStatement procName label exprTable paramMap varMap stmts stackMap = do
  { let label_a = procName ++ "_" ++ (showLabel label) ++ "_a"
  ; let label_b = procName ++ "_" ++ (showLabel label) ++ "_b"
  -- check condition
  ; generateExpression paramMap varMap exprTable 0 stackMap
  ; printLine ("branch_on_true r0, " ++ label_a)
  ; printLine ("branch_uncond " ++ label_b)
  -- If statements
  ; putStrLn (label_a ++ ":")
  ; generateStatements procName (label ++ [0] ++ [0]) paramMap varMap stmts stackMap
  -- end of this statements
  ; putStrLn (label_b ++ ":")
  }

-------------------------------------------------------------------------------
-- Generate oz code for an if-else statement
-------------------------------------------------------------------------------
generateIfElseStatement ::
  String -> [Int] -> ExpressionTable -> ParameterMap -> VariableMap -> [StatementTable] -> [StatementTable]
  -> StackMap -> IO ()
generateIfElseStatement procName label exprTable paramMap varMap stmts1 stmts2 stackMap = do
  { let label_a = procName ++ "_" ++ (showLabel label) ++ "_a"
  ; let label_b = procName ++ "_" ++ (showLabel label) ++ "_b"
  ; generateExpression paramMap varMap exprTable 0 stackMap
  -- Else statements
  ; printLine ("branch_on_false r0, " ++ label_a)
  -- If statements
  ; generateStatements procName (label ++ [1] ++ [0]) paramMap varMap stmts1 stackMap
  ; printLine ("branch_uncond " ++ label_b)
  -- Else statements
  ; putStrLn (label_a ++ ":")
  ; generateStatements procName (label ++ [2] ++ [0]) paramMap varMap stmts2 stackMap
  -- fi The end of If-Else
  ; putStrLn (label_b ++ ":")
  }

-------------------------------------------------------------------------------
-- Generate oz code for a while statement.
-------------------------------------------------------------------------------
generateWhileStatement ::
  String -> [Int] -> ExpressionTable -> ParameterMap -> VariableMap -> [StatementTable] -> StackMap -> IO ()
generateWhileStatement procName label exprTable paramMap varMap stmts stackMap = do
  { let label_a = procName ++ "_" ++ (showLabel label) ++ "_a"
  ; let label_b = procName ++ "_" ++ (showLabel label) ++ "_b"
  ; let label_c = procName ++ "_" ++ (showLabel label) ++ "_c"
  -- check condition
  ; putStrLn (label_a ++ ":")
  ; generateExpression paramMap varMap exprTable 0 stackMap
  ; printLine ("branch_on_true r0, " ++ label_b)
  ; printLine ("branch_uncond " ++ label_c)
  -- while statements
  ; putStrLn (label_b ++ ":")
  ; generateStatements procName (label ++ [3] ++ [0]) paramMap varMap stmts stackMap
  -- check condition again
  ; printLine ("branch_uncond " ++ label_a)
  -- end of this while loop
  ; putStrLn (label_c ++ ":")
  }

-------------------------------------------------------------------------------
-- Generate oz code for variable whose value is an expression.
-------------------------------------------------------------------------------
generateVariableExpr :: ParameterMap -> VariableMap -> VariableSubTable -> BaseType -> Int -> StackMap -> IO ()
generateVariableExpr paramMap varMap var varType regNum stackMap = do
  let varShape = varShapeIndicatorTable var
      varSlotNum = getVariableSlotNum var stackMap
      variableName = varName var
      varSlotNumStr = show varSlotNum
      regNumStr0 = "r" ++ (show regNum)
  case (Map.member variableName paramMap) of
    False -> do
      case varShape of
        NoIndicatorTable ->
          printLine $ "load " ++ regNumStr0 ++ ", " ++ varSlotNumStr
        otherwise        -> do
          { locateArrayMatrix paramMap varMap var varSlotNumStr regNum stackMap
          ; printLine $ "load_indirect " ++ regNumStr0 ++ ", " ++ regNumStr0
          }
    True -> do
      let parameter = snd $ paramMap Map.! variableName
          passType  = passingIndicator parameter
      case passType of
        VarType -> printLine $ "load " ++ regNumStr0 ++ ", " ++ varSlotNumStr
        RefType -> do
          { printLine $ "load " ++ regNumStr0 ++ ", " ++ varSlotNumStr
          ; printLine $ "load_indirect " ++ regNumStr0 ++ ", " ++ regNumStr0
          }

-------------------------------------------------------------------------------
-- Locate register of the value of a cell of an array/matrix for passing by ref.
-------------------------------------------------------------------------------
locateArrayMatrix ::
  ParameterMap -> VariableMap -> VariableSubTable -> String -> Int -> StackMap -> IO ()
locateArrayMatrix paramMap varMap var varSlotNumStr regNum stackMap = do
  let varShape = varShapeIndicatorTable var
      regNumStr0 = "r" ++ (show regNum)
      regNumStr1 = "r" ++ (show $ regNum + 1)
  case varShape of
    NoIndicatorTable ->
        printLine $ "load_address " ++ regNumStr0 ++ ", " ++ varSlotNumStr
    ArrayTable  expr -> do
      { printComment $ "Generate Array " ++ (varName var)
      ; generateExpression paramMap varMap expr regNum stackMap
      ; printLine $ "load_address " ++ regNumStr1 ++ ", " ++ varSlotNumStr
      ; printLine $ "sub_offset "   ++ regNumStr0 ++ ", " ++ regNumStr1 ++ ", " ++ regNumStr0
      }
    MatrixTable exprM exprN -> do
      { let varId    = varName var
            varDeclShape = varShapeIndicator $ declarationVariable (varMap Map.! varId)
            m = show $ getMatrixM varDeclShape
      ; printComment $ "Generate Matrix " ++ varId
      ; generateExpression paramMap varMap exprM regNum stackMap
      ; printLine $ "int_const " ++ regNumStr1 ++ ", " ++ m
      ; printLine $ "mul_int " ++ regNumStr0 ++ ", " ++ regNumStr0 ++ ", " ++ regNumStr1
      ; generateExpression paramMap varMap exprN (regNum+1) stackMap
      ; printLine $ "add_int "  ++ regNumStr0 ++ ", " ++ regNumStr1 ++ ", " ++ regNumStr0
      ; printLine $ "load_address " ++ regNumStr1 ++ ", " ++ varSlotNumStr
      ; printLine $ "sub_offset "  ++ regNumStr0 ++ ", " ++ regNumStr1 ++ ", " ++ regNumStr0
      }

-------------------------------------------------------------------------------
-- Get the row number of a matrix.
-------------------------------------------------------------------------------
getMatrixM :: ShapeIndicator -> Int
getMatrixM (Matrix (IntConst n) _ ) = n
  -- case m of
  --   IntConst n -> n

-------------------------------------------------------------------------------
-- Generate oz code for || expression.
-------------------------------------------------------------------------------
generateOrExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> StackMap -> IO ()
generateOrExpression paramMap varMap lExpr rExpr regNum stackMap = do
  generateAndOrExpr "or" paramMap varMap lExpr rExpr regNum stackMap

-------------------------------------------------------------------------------
-- Generate oz code for && expression.
-------------------------------------------------------------------------------
generateAndExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> StackMap -> IO ()
generateAndExpression paramMap varMap lExpr rExpr regNum stackMap = do
  generateAndOrExpr "and" paramMap varMap lExpr rExpr regNum stackMap

-------------------------------------------------------------------------------
-- Generate oz code for AND-OR expression.
-------------------------------------------------------------------------------
generateAndOrExpr ::
  String -> ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> StackMap -> IO ()
generateAndOrExpr operator paramMap varMap lExpr rExpr regNum stackMap = do
  { generateExpression paramMap varMap lExpr regNum stackMap
  ; generateExpression paramMap varMap rExpr (regNum+1) stackMap
  ; printLine $ operator ++ " r" ++ (show regNum) ++ ", r" ++ (show regNum) ++
                ", r" ++ (show (regNum+1))
  }

-------------------------------------------------------------------------------
-- Generate oz code for ! expression.
-------------------------------------------------------------------------------
generateNotExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> Int -> StackMap -> IO ()
generateNotExpression paramMap varMap expr regNum stackMap = do
  { generateExpression paramMap varMap expr regNum stackMap
  ; printLine $ "not r" ++ (show regNum) ++ ", r" ++ (show regNum)
  }

-------------------------------------------------------------------------------
-- Generate oz code for = expression.
-------------------------------------------------------------------------------
generateEqExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateEqExpression paramMap varMap lExpr rExpr regNum exprType stackMap = do
  generateCompareExpr "cmp_eq" paramMap varMap lExpr rExpr regNum exprType stackMap

-------------------------------------------------------------------------------
-- Generate oz code for != expression.
-------------------------------------------------------------------------------
generateNotEqExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateNotEqExpression paramMap varMap lExpr rExpr regNum exprType stackMap = do
  generateCompareExpr "cmp_ne" paramMap varMap lExpr rExpr regNum exprType stackMap

-------------------------------------------------------------------------------
-- Generate oz code for < expression.
-------------------------------------------------------------------------------
generateLesExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateLesExpression paramMap varMap lExpr rExpr regNum exprType stackMap = do
  generateCompareExpr "cmp_lt" paramMap varMap lExpr rExpr regNum exprType stackMap

-------------------------------------------------------------------------------
-- Generate oz code for <= expression.
-------------------------------------------------------------------------------
generateLesEqExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateLesEqExpression paramMap varMap lExpr rExpr regNum exprType stackMap = do
  generateCompareExpr "cmp_le" paramMap varMap lExpr rExpr regNum exprType stackMap

-------------------------------------------------------------------------------
-- Generate oz code for > expression.
-------------------------------------------------------------------------------
generateGrtExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateGrtExpression paramMap varMap lExpr rExpr regNum exprType stackMap = do
  generateCompareExpr "cmp_gt" paramMap varMap lExpr rExpr regNum exprType stackMap

-------------------------------------------------------------------------------
-- Generate oz code for >= expression.
-------------------------------------------------------------------------------
generateGrtEqExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateGrtEqExpression paramMap varMap lExpr rExpr regNum exprType stackMap = do
  generateCompareExpr "cmp_ge" paramMap varMap lExpr rExpr regNum exprType stackMap

-------------------------------------------------------------------------------
-- Generate comparison expression of a given type, which can be:
-- =, >, <, >=, <=
-------------------------------------------------------------------------------
generateCompareExpr ::
  String -> ParameterMap -> VariableMap -> ExpressionTable -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateCompareExpr operator paramMap varMap lExpr rExpr regNum exprType stackMap = do
  { generateExpression paramMap varMap lExpr regNum stackMap
  ; generateExpression paramMap varMap rExpr (regNum+1) stackMap
  ; case exprType of
      FloatType -> do
        generateIntToFloat lExpr rExpr regNum
        printLine $ operator ++ "_real r" ++ (show regNum) ++ ", r" ++
                    (show regNum) ++ ", r" ++ (show (regNum+1))
      otherwise ->
        printLine $ operator ++ "_int r" ++ (show regNum) ++ ", r" ++
                    (show regNum) ++ ", r" ++ (show (regNum+1))
  }

-------------------------------------------------------------------------------
-- Generate oz code for expressions with a single unary operator -.
-------------------------------------------------------------------------------
generateNegativeExpression ::
  ParameterMap -> VariableMap -> ExpressionTable -> Int -> BaseType -> StackMap -> IO ()
generateNegativeExpression paramMap varMap expr registerNum exprType stackMap = do
  { let regNum = show registerNum
  ; generateExpression paramMap varMap expr registerNum stackMap
  ; case exprType of
      IntType   -> printLine $ "neg_int r"  ++ regNum ++ ", r" ++ regNum
      FloatType -> printLine $ "neg_real r" ++ regNum ++ ", r" ++ regNum
  }

-------------------------------------------------------------------------------
-- Convert boolean to int.
-------------------------------------------------------------------------------
convertBoolToInt :: Bool -> String
convertBoolToInt boolVal =
  case boolVal of
    True  -> show 1
    False -> show 0

-------------------------------------------------------------------------------
-- Print a string with indentation.
-------------------------------------------------------------------------------
printLine :: String -> IO ()
printLine string = do
  { printNewLineIndentation
  ; putStrLn string
  }

-------------------------------------------------------------------------------
-- Generate oz code for comments.
-------------------------------------------------------------------------------
printComment :: String -> IO ()
printComment string = do
  { putStr "  # "
  ; putStrLn string
  }
-------------------------------------------------------------------------------
-- Register
-------------------------------------------------------------------------------
registers :: Map.Map register inputValue
registers = Map.empty






-------------------------------------------------------------------------------
-- Stack
-------------------------------------------------------------------------------





------------------------------- Helper functions ------------------------------
-------------------------------------------------------------------------------
-- Start a new line with proper indentation.
-------------------------------------------------------------------------------
printNewLineIndentation :: IO ()
printNewLineIndentation = putStr "    "

-------------------------------------------------------------------------------
-- Create the Oz statement: int_to_real r0 r1, where 0 and 1 are provided
-- register numbers.
-------------------------------------------------------------------------------
printIntToRealInNewRegister :: Int -> Int -> IO ()
printIntToRealInNewRegister targetRegisterNumber sourceRegisterNumber = do
  printLine $ "int_to_real r" ++ (show targetRegisterNumber) ++
              ", r" ++ (show sourceRegisterNumber)

-------------------------------------------------------------------------------
-- Create the Oz statement: int_to_real r0 r0, where 0 is the provided register
-- number.
-------------------------------------------------------------------------------
printIntToRealInSameRegister :: Int -> IO ()
printIntToRealInSameRegister registerNumber = do
  printIntToRealInNewRegister registerNumber registerNumber

-------------------------------------------------------------------------------
-- Generate string for binary operators.
-------------------------------------------------------------------------------
generateOperationString :: String -> String -> Int -> IO ()
generateOperationString operator opType registerNum = do
  printNewLineIndentation
  putStrLn $ operator ++ "_" ++ opType ++ " r" ++ (show registerNum)
    ++ ", r" ++ (show registerNum) ++ ", r" ++
    (show $ registerNum+1)

-------------------------------------------------------------------------------
-- Convert int type to float type.
-------------------------------------------------------------------------------
generateIntToFloat :: ExpressionTable -> ExpressionTable -> Int -> IO ()
generateIntToFloat lExpr rExpr registerNum = do
    let lType = getExpressionBaseType lExpr
        rType = getExpressionBaseType rExpr
    case (lType,rType) of
        (FloatType,FloatType) -> return ()
        (IntType,FloatType) -> printIntToRealInSameRegister registerNum
        (FloatType,IntType) -> printIntToRealInSameRegister (registerNum + 1)

-------------------------------------------------------------------------------
-- Get a non-conflicting slot number for a new variable.
-------------------------------------------------------------------------------
getVariableSlotNum :: VariableSubTable -> StackMap -> Int
getVariableSlotNum variable stackMap = stackMap Map.! varId
  where varId = varName variable

-------------------------------------------------------------------------------
-- Get the size of VariableMap.
-------------------------------------------------------------------------------
getVariableMapSize :: [Identifier] -> VariableMap -> Int
getVariableMapSize [] _ = 0
getVariableMapSize (var:[]) varMap =
  getVariableSize varIndicator
  where varIndicator = varShapeIndicator $ declarationVariable (varMap Map.! var)
getVariableMapSize (var:vars) varMap =
  (getVariableSize varIndicator) + (getVariableMapSize vars varMap)
  where varIndicator = varShapeIndicator $ declarationVariable (varMap Map.! var)

-------------------------------------------------------------------------------
-- Get the size of a variable.
-- Array/matrix: the size of object
-- Neither: 1
-------------------------------------------------------------------------------
getVariableSize :: ShapeIndicator -> Int
getVariableSize varIndicator =
  case varIndicator of
    NoIndicator                      -> 1
    Array  (IntConst n)              -> n
    Matrix (IntConst m) (IntConst n) -> m*n

-------------------------------------------------------------------------------
-- Generate a StackMap, given the parameters and variables of a procedure.
-------------------------------------------------------------------------------
insertStackMap :: ParameterMap -> VariableMap -> StackMap
insertStackMap paramMap varMap = do
    let paramList = Map.keys paramMap
        varList = Map.keys varMap
        stackList = paramList ++ varList
    subinsertStackMap stackList 0 varMap


-------------------------------------------------------------------------------
-- Example:
-- Using add_offset to access Array and Matrix
--   Array x[4]    from slot 0 to 4
--   Matrix x[2,3] from slot 0 to 6
-------------------------------------------------------------------------------
subinsertStackMap :: [String] -> Int -> VariableMap -> StackMap
subinsertStackMap (name:[]) index varMap =
  case (Map.member name varMap) of
    True  -> Map.insert name index Map.empty
        where varIndicator = varShapeIndicator $ declarationVariable (varMap Map.! name)
              varSize = getVariableSize varIndicator
    False -> Map.insert name index Map.empty
subinsertStackMap (name:names) index varMap =
  case (Map.member name varMap) of
    True  -> Map.insert name index (subinsertStackMap names (index+varSize) varMap)
        where varIndicator = varShapeIndicator $ declarationVariable (varMap Map.! name)
              varSize = getVariableSize varIndicator
    False -> Map.insert name index (subinsertStackMap names (index+1) varMap)
============================================
src/Makefile
17:43:35_Wednesday_29_May_2019
============================================
###############################################################################
#
# Authors:
#   Shizhe Cai (shizhec) - 798125
#   Weizhuo Zhang (weizhuoz) - 1018329
#   Mingyang Zhang (mingyangz) - 650242
#   An Luo (aluo1) - 657605
#
# This is the make file of proejct of COMP90045, Programming Language
# Implementation.
#
###############################################################################

Goat: Goat.hs GoatParser.hs GoatAST.hs GoatPrettyPrint.hs
	ghc Goat.hs -o Goat

clean:
	rm -f *.o *.hi *.out
	rm -f Goat
============================================
src/GoatPrettyPrint.hs
17:43:38_Wednesday_29_May_2019
============================================
module GoatPrettyPrint where

import           GoatAST
import           GoatConstant
import           GoatExit
import           System.Exit
import           Util

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the pretty print-related information of the Goat program.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Number of white space needed for indentation.
-------------------------------------------------------------------------------
indentationSpaceNumber :: Int
indentationSpaceNumber = 4

-------------------------------------------------------------------------------
-- Print indention.
-------------------------------------------------------------------------------
printIndentation :: Int -> IO ()
printIndentation 0 = return ()
printIndentation numberOfSpace = do { printOneWhiteSpace
                                    ; printIndentation (numberOfSpace - 1)
                                    }

-------------------------------------------------------------------------------
-- Print one white space.
-------------------------------------------------------------------------------
printOneWhiteSpace :: IO ()
printOneWhiteSpace = putStr " "

-------------------------------------------------------------------------------
-- Print semicolon, together with the new line character.
-------------------------------------------------------------------------------
printSemiColon :: IO ()
printSemiColon = putStrLn ";"

-------------------------------------------------------------------------------
-- Print BaseType: bool, float and int.
-------------------------------------------------------------------------------
printBaseType :: BaseType -> IO ()
printBaseType baseType = do
    case baseType of
        BoolType  -> putStr "bool"
        IntType   -> putStr "int"
        FloatType -> putStr "float"

-------------------------------------------------------------------------------
-- Print Passing Indicator type: "val" and "ref".
-------------------------------------------------------------------------------
printParameterIndicator :: ParameterIndicator -> IO ()
printParameterIndicator parameterIndicator = do
    case parameterIndicator of
        VarType -> putStr "val"
        RefType -> putStr "ref"

-------------------------------------------------------------------------------
-- Get String of shape Indicator type such as Array and Matrix.
-------------------------------------------------------------------------------
getShapeIndicator :: ShapeIndicator -> String
getShapeIndicator shapeIndicator =
    case shapeIndicator of
        NoIndicator -> ""
        Array  n    -> "[" ++ (getTopExpr n) ++ "]"
        Matrix m n  -> "[" ++ (getTopExpr m) ++ ", " ++ (getTopExpr n) ++ "]"

-------------------------------------------------------------------------------
-- Get String of variable in form id, id[n] or id[m,n].
-------------------------------------------------------------------------------
getVariable :: Variable -> String
getVariable variable = (varId variable)
                    ++ (getShapeIndicator $ varShapeIndicator variable)

-------------------------------------------------------------------------------
-- Print Parameters of procedure
-------------------------------------------------------------------------------
printParameters :: [Parameter] -> String -> IO ()
printParameters [] _                     = return ()
printParameters (param:params) seperator = do
    { putStr seperator
    ; printParameterIndicator $ passingIndicator param
    ; printOneWhiteSpace
    ; printBaseType $ passingType param
    ; printOneWhiteSpace
    ; putStr $ passingIdent param
    ; printParameters (params) ", "
    }

-------------------------------------------------------------------------------
-- Print procedure header.
-------------------------------------------------------------------------------
printHeader :: Header -> IO ()
printHeader header = do { putStr   "proc "
                        ; putStr $ headerIdent $ header
                        ; putStr   " ("
                        ; printParameters (parameters $ header) ""
                        ; putStr   ")"
                        ; putStrLn "" -- print new line character
                        }

-------------------------------------------------------------------------------
-- Print variables declaration.
-------------------------------------------------------------------------------
printVariableDeclaration :: [VariableDeclaration] -> IO ()
printVariableDeclaration []                                 = return ()
printVariableDeclaration (variableDeclaration:declarations) = do
    { printIndentation indentationSpaceNumber
    ; printBaseType $ declarationType variableDeclaration
    ; printOneWhiteSpace
    ; putStr $ getVariable $ declarationVariable variableDeclaration
    ; printSemiColon
    ; printVariableDeclaration declarations
    }

-------------------------------------------------------------------------------
-- Print Assignment Statements such as n := 34;
-------------------------------------------------------------------------------
printAssignStatement :: Variable -> Expression -> Int -> IO ()
printAssignStatement variable expression numberOfSpace = do
    { printIndentation numberOfSpace
    ; putStr $ getVariable variable
    ; printOneWhiteSpace
    ; putStr ":="
    ; printOneWhiteSpace
    ; putStr $ getTopExpr expression
    ; printSemiColon
    }

-------------------------------------------------------------------------------
-- Print Read Statements such as read n[3,5];
-------------------------------------------------------------------------------
printReadStatement :: Variable -> Int -> IO ()
printReadStatement variable numberOfSpace = do { printIndentation numberOfSpace
                                               ; putStr "read"
                                               ; printOneWhiteSpace
                                               ; putStr $ getVariable variable
                                               ; printSemiColon
                                               }

-------------------------------------------------------------------------------
-- Print Write Statements such as write 3 + 5;
-------------------------------------------------------------------------------
printWriteStatement :: Expression -> Int -> IO ()
printWriteStatement expression numberOfSpace = do
    { printIndentation numberOfSpace
    ; putStr "write"
    ; printOneWhiteSpace
    ; putStr $ getTopExpr expression
    ; printSemiColon
    }

-------------------------------------------------------------------------------
-- Print Call Statements such as call n(3 + 5);
-------------------------------------------------------------------------------
printCallStatement :: Identifier -> [Expression] -> Int -> IO ()
printCallStatement id expressions numberOfSpace = do
    { printIndentation numberOfSpace
    ; putStr "call "
    ; putStr id
    ; putStr "("
    ; printExprs expressions ""
    ; putStr ")"
    ; printSemiColon
    }

-------------------------------------------------------------------------------
-- Print the common part of If Statements and If-Else Statements.
-------------------------------------------------------------------------------
printIfCommon :: Expression -> [Statement] -> Int -> IO ()
printIfCommon expression statements numberOfSpace = do
    { printIndentation numberOfSpace
    ; putStr "if "
    ; printExprs [expression] ""
    ; putStrLn " then"
    ; printStatements statements (numberOfSpace + indentationSpaceNumber)
    }

-------------------------------------------------------------------------------
-- print the end part of If Statements and If-Else Statements.
-------------------------------------------------------------------------------
printIfEnd :: Int -> IO ()
printIfEnd numberOfSpace = do { printIndentation numberOfSpace
                              ; putStrLn "fi"
                              }

-------------------------------------------------------------------------------
-- Print If Statements.
-------------------------------------------------------------------------------
printIfStatement :: Expression -> [Statement] -> Int -> IO ()
printIfStatement expression statements numberOfSpace = do
    { printIfCommon expression statements numberOfSpace
    ; printIfEnd numberOfSpace
    }

-------------------------------------------------------------------------------
-- Print If-Else Statements
-------------------------------------------------------------------------------
printIfElseStatement :: Expression -> [Statement] -> [Statement] -> Int -> IO ()
printIfElseStatement expression statement1 statement2 numberOfSpace = do
    { printIfCommon expression statement1 numberOfSpace
    ; printIndentation numberOfSpace
    ; putStrLn "else"
    ; printStatements statement2 (numberOfSpace + indentationSpaceNumber)
    ; printIfEnd numberOfSpace
    }

-------------------------------------------------------------------------------
-- Print While Statements.
-------------------------------------------------------------------------------
printWhileStatement :: Expression -> [Statement] -> Int -> IO ()
printWhileStatement expression statements numberOfSpace = do
    { printIndentation numberOfSpace
    ; putStr "while "
    ; printExprs [expression] ""
    ; putStrLn " do"
    ; printStatements statements (numberOfSpace + indentationSpaceNumber)
    ; printIndentation numberOfSpace
    ; putStrLn "od"
    }

-------------------------------------------------------------------------------
-- Print statement.
-------------------------------------------------------------------------------
printStatement :: Statement -> Int -> IO ()
printStatement statement numberOfSpace = do
    case statement of
        Assign variable  expression    -> printAssignStatement variable
                                                               expression
                                                               numberOfSpace
        Read   variable                -> printReadStatement   variable
                                                               numberOfSpace
        Write  expression              -> printWriteStatement  expression
                                                               numberOfSpace
        Call   id   expressions        -> printCallStatement   id
                                                               expressions
                                                               numberOfSpace
        If     expression statements   -> printIfStatement     expression
                                                               statements
                                                               numberOfSpace
        IfElse expression statement1 statement2
                                       -> printIfElseStatement expression
                                                               statement1
                                                               statement2
                                                               numberOfSpace
        While  expression statements   -> printWhileStatement  expression
                                                               statements
                                                               numberOfSpace

-------------------------------------------------------------------------------
-- Print statement list.
-------------------------------------------------------------------------------
printStatements :: [Statement] -> Int -> IO ()
printStatements [] _                                 = return ()
printStatements (statement:statements) numberOfSpace = do
    { printStatement statement numberOfSpace
    ; printStatements statements numberOfSpace
    }

-------------------------------------------------------------------------------
-- Convert constant variable to string.
-------------------------------------------------------------------------------
getConst :: (Show a) => a -> String
getConst a = show a

-------------------------------------------------------------------------------
-- Convert bool constant variable to string.
-------------------------------------------------------------------------------
getBoolConst :: Bool -> String
getBoolConst True  = "true"
getBoolConst False = "false"

-------------------------------------------------------------------------------
-- Get string of result using infix operator.
-------------------------------------------------------------------------------
getInfixOpResult :: Expression -> String -> Expression -> String
getInfixOpResult lExpr operator rExpr = (getExpr lExpr)
                                      ++ operator
                                      ++ (getExpr rExpr)

-------------------------------------------------------------------------------
-- Get string of result using prefix operator
-------------------------------------------------------------------------------
getPrefixOpResult :: Expression -> String -> String
getPrefixOpResult expression operator = operator ++ (getExpr expression)

-------------------------------------------------------------------------------
-- Print list of expressionessions.
-------------------------------------------------------------------------------
printExprs :: [Expression] -> String -> IO ()
printExprs [] _                               = return ()
printExprs (expression:expressions) seperator = do
    { putStr seperator
    ; putStr $ getTopExpr expression
    ; printExprs expressions ", "
    }

-------------------------------------------------------------------------------
-- Print the root of expressionesssion which should no surrounded by ().
-------------------------------------------------------------------------------
getTopExpr :: Expression -> String
getTopExpr expression =
    case expression of
        ExprVar     variable   -> getVariable variable
        BoolConst   val        -> getBoolConst val
        IntConst    val        -> getConst val
        FloatConst  val        -> getConst val
        StrConst    val        -> wrapWithDoubleQuotations val
        Add   lExpr rExpr      -> getInfixOpResult  lExpr " + "  rExpr
        Mul   lExpr rExpr      -> getInfixOpResult  lExpr " * "  rExpr
        Sub   lExpr rExpr      -> getInfixOpResult  lExpr " - "  rExpr
        Div   lExpr rExpr      -> getInfixOpResult  lExpr " / "  rExpr
        Or    lExpr rExpr      -> getInfixOpResult  lExpr " || " rExpr
        And   lExpr rExpr      -> getInfixOpResult  lExpr " && " rExpr
        Eq    lExpr rExpr      -> getInfixOpResult  lExpr " = "  rExpr
        NotEq lExpr rExpr      -> getInfixOpResult  lExpr " != " rExpr
        Les   lExpr rExpr      -> getInfixOpResult  lExpr " < "  rExpr
        LesEq lExpr rExpr      -> getInfixOpResult  lExpr " <= " rExpr
        Grt   lExpr rExpr      -> getInfixOpResult  lExpr " > "  rExpr
        GrtEq lExpr rExpr      -> getInfixOpResult  lExpr " >= " rExpr
        UnaryMinus  expression -> getPrefixOpResult expression minusSymbol
        UnaryNot    expression -> getPrefixOpResult expression unaryNotSymbol

-------------------------------------------------------------------------------
-- Wrap the given string with parenthesis.
-------------------------------------------------------------------------------
wrapStringWithParen :: String -> String
wrapStringWithParen value = "(" ++ value ++ ")"

-------------------------------------------------------------------------------
-- Print the non-root of expressionesssion which might surrounded by ().
-------------------------------------------------------------------------------
getExpr :: Expression -> String
getExpr expression =
    let expressionString = getTopExpr expression
    in case expression of
        Add   _ _ -> wrapStringWithParen expressionString
        Mul   _ _ -> wrapStringWithParen expressionString
        Sub   _ _ -> wrapStringWithParen expressionString
        Div   _ _ -> wrapStringWithParen expressionString
        Or    _ _ -> wrapStringWithParen expressionString
        And   _ _ -> wrapStringWithParen expressionString
        Eq    _ _ -> wrapStringWithParen expressionString
        NotEq _ _ -> wrapStringWithParen expressionString
        Les   _ _ -> wrapStringWithParen expressionString
        LesEq _ _ -> wrapStringWithParen expressionString
        Grt   _ _ -> wrapStringWithParen expressionString
        GrtEq _ _ -> wrapStringWithParen expressionString
        otherwise -> expressionString

-------------------------------------------------------------------------------
-- Print Body.
-------------------------------------------------------------------------------
printBody :: Body -> IO ()
printBody body = do { printVariableDeclaration $ bodyVarDeclarations body
                    ; putStrLn "begin"
                    ; printStatements (bodyStatements body) indentationSpaceNumber
                    ; putStrLn "end"
                    }

-------------------------------------------------------------------------------
-- print Procedure
-------------------------------------------------------------------------------
printProc :: [Procedure] -> IO ()
printProc []           = return ()
printProc (proc:[])    = do { printHeader $ header proc
                            ; printBody $ body proc
                            }
printProc (proc:procs) = do { printHeader $ header proc
                            ; printBody $ body proc
                            ; putStrLn "" -- print new line character
                            ; printProc (procs)
                            }

-------------------------------------------------------------------------------
-- Main entry of prettyPrint module.
-------------------------------------------------------------------------------
prettyPrint :: GoatProgram -> IO ()
prettyPrint program = printProc (procedures program)
============================================
src/GoatAST.hs
17:43:37_Wednesday_29_May_2019
============================================
module GoatAST where

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the abstract syntax tree for the Goat language.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

-------------------------------------------------------------------------------
-- Identifier.
-------------------------------------------------------------------------------
type Identifier = String

-------------------------------------------------------------------------------
-- Base type.
-------------------------------------------------------------------------------
data BaseType = BoolType | IntType | FloatType deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Variable.
-------------------------------------------------------------------------------
data Variable = Variable { varId             :: Identifier
                         , varShapeIndicator :: ShapeIndicator
                         } deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Expression.
-------------------------------------------------------------------------------
data Expression = ExprVar    { exprVar          :: Variable }
                | BoolConst  { boolConstVal     :: Bool }
                | IntConst   { intConstVal      :: Int }
                | FloatConst { floatConstVal    :: Float }
                | StrConst   { strConstVal      :: String }
                | Add        { addLeftExpr  :: Expression
                             , addRightExpr :: Expression
                             }
                | Mul        { mulLeftExpr  :: Expression
                             , mulRightExpr :: Expression
                             }
                | Sub        { subLeftExpr  :: Expression
                             , subRightExpr :: Expression
                             }
                | Div        { divLeftExpr  :: Expression
                             , divRightExpr :: Expression
                             }
                | Or         { orLeftExpr  :: Expression
                             , orRightExpr :: Expression
                             }
                | And        { andLeftExpr  :: Expression
                             , andRightExpr :: Expression
                             }
                | Eq         { eqLeftExpr  :: Expression
                             , eqRightExpr :: Expression
                             }
                | NotEq      { notEqLeftExpr  :: Expression
                             , notEqRightExpr :: Expression
                             }
                | Les        { lesLeftExpr  :: Expression
                             , lesRightExpr :: Expression
                             }
                | LesEq      { lesEqLeftExpr  :: Expression
                             , lesEqRightExpr :: Expression
                             }
                | Grt        { grtLeftExpr  :: Expression
                             , grtRightExpr :: Expression
                             }
                | GrtEq      { grtEqLeftExpr  :: Expression
                             , grtEqRightExpr :: Expression
                             }
                | UnaryMinus { unaryMinusExpr :: Expression }
                | UnaryNot   { unaryNotExpr :: Expression }
                deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Variable Declaration.
-------------------------------------------------------------------------------
data VariableDeclaration = VariableDeclaration
                           { declarationType     :: BaseType
                           , declarationVariable :: Variable
                           } deriving (Show, Eq)

 ------------------------------------------------------------------------------
 -- Statement types.
 ------------------------------------------------------------------------------
data Statement = Assign { assignVal  :: Variable
                        , assignExpr :: Expression
                        }
               | Read   { readVal          :: Variable }
               | Write  { writeExpr        :: Expression }
               | Call   { callIdent :: Identifier
                        , callExprs :: [Expression]
                        }
               | If     { ifExpr       :: Expression
                        , ifStatements :: [Statement]
                        }
               | IfElse { ifElseExpr        :: Expression
                        , ifElseStatements1 :: [Statement]
                        , ifElseStatements2 :: [Statement]
                        }
               | While  { whileExpr       :: Expression
                        , whileStatements :: [Statement]
                        }
               deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Procedure body.
-------------------------------------------------------------------------------
data Body = Body { bodyVarDeclarations :: [VariableDeclaration]
                 , bodyStatements      :: [Statement]
                 } deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Procedure indicator types.
-------------------------------------------------------------------------------
data ParameterIndicator = VarType | RefType deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Shape indicator types.
-------------------------------------------------------------------------------
data ShapeIndicator = Array  { arrayExpr :: Expression }
                    | Matrix { matrixMExpr :: Expression
                             , matrixNExpr :: Expression
                             }
                    | NoIndicator
                    deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Procedure parameter types.
-------------------------------------------------------------------------------
data Parameter = Parameter { passingIndicator :: ParameterIndicator
                           , passingType      :: BaseType
                           , passingIdent     :: Identifier
                           } deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Procedure header.
-------------------------------------------------------------------------------
data Header = Header { headerIdent :: Identifier
                     , parameters  :: [Parameter]
                     } deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Procedure.
-------------------------------------------------------------------------------
data Procedure = Procedure { header :: Header
                           , body   :: Body
                           } deriving (Show, Eq)

-------------------------------------------------------------------------------
-- Goat program types.
-------------------------------------------------------------------------------
data GoatProgram = GoatProgram { procedures :: [Procedure]} deriving (Show, Eq)
============================================
src/Analyzer.hs
17:43:35_Wednesday_29_May_2019
============================================
module Analyzer where

import           AnalyzerUtil
import qualified Data.Map.Strict as M
import           Data.Maybe
import           GoatAST
import           GoatConstant
import           GoatExit
import           SymbolTable
import           Util

-------------------------------- Documentation --------------------------------

-- Authors:
--   Shizhe Cai (shizhec) - 798125
--   Weizhuo Zhang (weizhuoz) - 1018329
--   Mingyang Zhang (mingyangz) - 650242
--   An Luo (aluo1) - 657605

-- This file contains the codes that analyze AST's semantics.

-- The aim of the project is to implement a compiler for a procedural (C-like)
-- language called Goat.

-------------------------------- Documentation --------------------------------

insertVariableMap ::
  Identifier -> [VariableDeclaration] -> ParameterMap -> VariableMap ->
  Either (IO Task) VariableMap
insertVariableMap procName [] paramMap varMap = Right varMap
insertVariableMap procName (bodyVarDecl:[]) paramMap varMap = do
  let varName = varId $ declarationVariable bodyVarDecl
  case (M.member varName paramMap) of
    True  -> Left $ exitWithMultipleVarDeclaration varName procName
    False -> Right $ M.insert varName bodyVarDecl varMap
insertVariableMap procName (bodyVarDecl:bodyVarDecls) paramMap varMap = do
  let varName = varId $ declarationVariable bodyVarDecl
  case (M.member varName paramMap) of
    True  -> Left $ exitWithMultipleVarDeclaration varName procName
    False -> do
      let newVarMap = insertVariableMap procName bodyVarDecls paramMap varMap
      case newVarMap of
        Left err -> Left err
        Right subVarMap -> do
          case (M.member varName subVarMap) of
            True  -> Left $ exitWithMultipleVarDeclaration varName procName
            False -> Right $ M.insert varName bodyVarDecl subVarMap

insertStatementList ::
  Identifier -> [Statement] -> ParameterMap -> VariableMap -> ProgramMap ->
  Either (IO Task) [StatementTable]
insertStatementList procName (stmt:[]) paramMap varMap procMap = do
  let newStmtTable = checkStatement procName stmt paramMap varMap procMap
  case newStmtTable of
    Left err        -> Left err
    Right stmtTable -> Right $ (stmtTable):[]
insertStatementList procName (stmt:stmts) paramMap varMap procMap = do
  let newStatements = insertStatementList procName stmts paramMap varMap procMap
  case newStatements of
    Left err            -> Left err
    Right subStatements -> do
      let newStmtTable = checkStatement procName stmt paramMap varMap procMap
      case newStmtTable of
        Left err        -> Left err
        Right stmtTable -> Right $ (stmtTable):subStatements

checkStatement ::
  Identifier -> Statement -> ParameterMap -> VariableMap -> ProgramMap ->
  Either (IO Task) StatementTable
checkStatement procName stmt paramMap varMap procMap =
  case stmt of
    Write expr -> checkWriteStmt procName expr paramMap varMap
    Read var -> do
      let eitherReadStatement = checkReadStmt procName var paramMap varMap
      case eitherReadStatement of
          Left err        -> Left err
          Right exprTable -> Right $ ReadTable exprTable
    Assign var expression -> do
      -- Assignment statement, e.g. a := 1
      let eitherVariableTable = checkVariable procName var paramMap varMap
      case eitherVariableTable of
          Left err            -> Left err
          Right variableTable -> do
              checkAssignExpr procName expression variableTable paramMap varMap
    If expr stmts -> do
      let exprEither = checkCondition procName expr paramMap varMap
      case exprEither of
        Left err -> Left err
        Right exprTable -> do
          let stmtTablesEither = insertStatementList procName stmts paramMap varMap procMap
          case stmtTablesEither of
            Left err         -> Left err
            Right stmtTables -> Right $ IfTable exprTable stmtTables
    IfElse expr stmts1 stmts2 -> do
      let exprEither = checkCondition procName expr paramMap varMap
      case exprEither of
        Left err -> Left err
        Right exprTable -> do
          let stmtTablesEither1 = insertStatementList procName stmts1 paramMap varMap procMap
          case stmtTablesEither1 of
            Left err -> Left err
            Right stmtTables1 -> do
              let stmtTablesEither2 = insertStatementList procName stmts2 paramMap varMap procMap
              case stmtTablesEither2 of
                Left err -> Left err
                Right stmtTables2 -> do
                  Right $ IfElseTable exprTable stmtTables1 stmtTables2
    While expr stmts -> do
      let exprEither = checkCondition procName expr paramMap varMap
      case exprEither of
        Left err -> Left err
        Right exprTable -> do
          let stmtTablesEither = insertStatementList procName stmts paramMap varMap procMap
          case stmtTablesEither of
            Left err         -> Left err
            Right stmtTables -> Right $ WhileTable exprTable stmtTables
    Call procId argExprs -> do
      let exprsEither = checkCallStmt procName procId argExprs procMap paramMap varMap
      case exprsEither of
        Left err -> Left err
        Right (expreTables, params) -> Right $ CallTable procId expreTables params

-------------------------------------------------------------------------------
-- Check the write statement, and return the statement table if it's correct,
-- otherwise exit the program with error.
-------------------------------------------------------------------------------
checkArguments ::
  Identifier -> Identifier -> [Expression] -> [BaseType] -> [Parameter] ->
  ParameterMap -> VariableMap -> Either (IO Task) [ExpressionTable]
checkArguments procName procId (expression:[]) (baseType:[]) (parameter:[]) paramMap varMap = do
  let paramIndicator  = (passingIndicator parameter)
      eitherExprTable = checkCallExpr
                        procName
                        procId
                        paramIndicator
                        expression
                        paramMap
                        varMap
  case eitherExprTable of
    Left err -> Left err
    Right expressionTable -> do
      let exprBaseType = getExpressionBaseType expressionTable
      if (exprBaseType == baseType)
      then Right [expressionTable]
      else case paramIndicator of
             RefType -> Left $ exitWithCallParamLengthDiff procName procId
             VarType -> if (FloatType == baseType && IntType == exprBaseType)
                        then Right [expressionTable]
                        else Left $ exitWithCallParamLengthDiff procName procId
checkArguments procName procId (expression:expressions) (baseType:baseTypeList) (parameter:parameters) paramMap varMap = do
  let expressionTables = checkArguments procName procId expressions baseTypeList parameters paramMap varMap
  case expressionTables of
    Left err -> Left err
    Right exprTables -> do
      let paramIndicator  = (passingIndicator parameter)
          eitherExprTable =
                checkCallExpr procName procId paramIndicator expression paramMap varMap
      case eitherExprTable of
        Left err -> Left err
        Right expressionTable -> do
          let exprBaseType = getExpressionBaseType expressionTable
          if (exprBaseType == baseType) then
            Right $ [expressionTable] ++ exprTables
          else
            case paramIndicator of
              RefType -> Left $ exitWithCallParamLengthDiff procName procId
              VarType -> if (FloatType == baseType && IntType == exprBaseType)
                        then Right $ [expressionTable] ++ exprTables
                        else Left $ exitWithCallParamLengthDiff procName procId

checkCallExpr ::
  Identifier -> Identifier -> ParameterIndicator -> Expression ->
  ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkCallExpr procName procId paramIndicator expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right expressionTable -> do
      case paramIndicator of
        VarType -> Right expressionTable
        RefType -> do
          case expressionTable of
             VariableTable _ _ -> Right  expressionTable
             otherwise         -> Left $ exitWithInvalidCallExpr procName procId

-------------------------------------------------------------------------------
-- Check the call statement, and return the statement table if it's correct,
-- otherwise exit the program with error.
-------------------------------------------------------------------------------
checkCallStmt ::
  Identifier -> Identifier -> [Expression] -> ProgramMap -> ParameterMap ->
  VariableMap -> Either (IO Task) ([ExpressionTable], [Parameter])
checkCallStmt procName calledProcId argExprs procMap paramMap varMap = do
  case M.lookup calledProcId procMap of
    Just calledProcTable -> do
      let paramList = paramMapToList $ parameterMap calledProcTable
          paramBaseTypes = [passingType param | param <- paramList]
      case ((length argExprs) == (length paramList)) of
        True -> do
          case ((length argExprs) == 0) of
            True -> Right ([], [])
            otherwise -> do
              let expreTables = checkArguments
                                procName
                                calledProcId
                                argExprs
                                paramBaseTypes
                                paramList
                                paramMap
                                varMap
              case expreTables of
                Left err               -> Left err
                Right expressionTables -> Right (expressionTables, paramList)
        otherwise -> Left $ exitWithCallParamLengthDiff procName calledProcId
    Nothing -> Left $ exitWithProcNotFound procName calledProcId

-------------------------------------------------------------------------------
-- Check the write statement, and return the statement table if it's correct,
-- otherwise exit the program with error.
-------------------------------------------------------------------------------
checkWriteStmt ::
  Identifier -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) StatementTable
checkWriteStmt procName expr paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
  case eitherExpressionTable of
    Left err        -> Left err
    Right exprTable -> Right $ WriteTable exprTable

-------------------------------------------------------------------------------
-- Check the read statement, and return the statement table if it's correct,
-- otherwise exit the program with error.
-------------------------------------------------------------------------------
checkReadStmt ::
  Identifier -> Variable -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkReadStmt procName var paramMap varMap = do
  let eitherExpressionTable = checkVariable procName var paramMap varMap
  case eitherExpressionTable of
    Left err        -> Left err
    Right exprTable -> Right exprTable

-------------------------------------------------------------------------------
-- Check the assignemnt statement, and return the statement table if it's
-- correct, otherwise exit the program with error.
-------------------------------------------------------------------------------
checkAssignExpr ::
  Identifier -> Expression -> ExpressionTable -> ParameterMap ->
  VariableMap -> Either (IO Task) StatementTable
checkAssignExpr procName expr variableTable paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
  case eitherExpressionTable of
    Left err        -> Left err
    Right expressionTable -> do
      let exprType = getExpressionBaseType expressionTable
      checkAssignType procName variableTable expressionTable exprType

-------------------------------------------------------------------------------
-- Check the condition and return the expression table if it's correct,
-- otherwise exit the program.
-------------------------------------------------------------------------------
checkCondition ::
  Identifier -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkCondition procName expr paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
      errorExit = exitWithConditionTypeError procName
  case eitherExpressionTable of
    Left err -> Left err
    Right exprTable -> do
      case exprTable of
        VariableTable _ varType -> do
          case varType of
            BoolType  -> Right exprTable
            otherwise -> Left errorExit
        BoolTable  _     -> Right exprTable
        OrTable    _ _ _ -> Right exprTable
        AndTable   _ _ _ -> Right exprTable
        NotTable   _ _   -> Right exprTable
        EqTable    _ _ _ -> Right exprTable
        NotEqTable _ _ _ -> Right exprTable
        LesTable   _ _ _ -> Right exprTable
        LesEqTable _ _ _ -> Right exprTable
        GrtTable   _ _ _ -> Right exprTable
        GrtEqTable _ _ _ -> Right exprTable
        otherwise        -> Left errorExit

-------------------------------------------------------------------------------
-- Check if expression is correct, and return the expression type if so.
-------------------------------------------------------------------------------
checkExpression ::
  Identifier -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkExpression procName expr paramMap varMap = do
  case expr of
    BoolConst  val -> Right $ BoolTable val
    IntConst   val -> Right $ IntTable val
    FloatConst val -> Right $ FloatTable val
    StrConst   val -> Right $ StringTable val
    ExprVar    val -> do
      let eitherVariableExpression = checkVariable procName val paramMap varMap
      case eitherVariableExpression of
        Left err                 -> Left err
        Right variableExpression -> Right variableExpression
    Add lExpr rExpr -> do
      let eitherAddExpression = checkArthmeticOperation
                                procName
                                addSymbol
                                lExpr
                                rExpr
                                paramMap
                                varMap
      case eitherAddExpression of
        Left err            -> Left err
        Right addExpression -> Right addExpression
    Mul lExpr rExpr -> do
      let eitherMulExpression = checkArthmeticOperation
                                procName
                                timesSymbol
                                lExpr
                                rExpr
                                paramMap
                                varMap
      case eitherMulExpression of
        Left err            -> Left err
        Right mulExpression -> Right mulExpression
    Sub lExpr rExpr -> do
      let eitherSubExpression = checkArthmeticOperation
                                procName
                                minusSymbol
                                lExpr
                                rExpr
                                paramMap
                                varMap
      case eitherSubExpression of
        Left err            -> Left err
        Right subExpression -> Right subExpression
    Div lExpr rExpr -> do
      let eitherDivExpression = checkArthmeticOperation
                                procName
                                divSymbol
                                lExpr
                                rExpr
                                paramMap
                                varMap
      case eitherDivExpression of
        Left err            -> Left err
        Right divExpression -> Right divExpression
    Or    lExpr rExpr -> checkLogicExpression
                         procName
                         orSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    And   lExpr rExpr -> checkLogicExpression
                         procName
                         andSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    Eq    lExpr rExpr -> checkCompareExpression
                         procName
                         equalSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    NotEq lExpr rExpr -> checkCompareExpression
                         procName
                         notEqualSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    Les   lExpr rExpr -> checkCompareExpression
                         procName
                         lessThanSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    LesEq lExpr rExpr -> checkCompareExpression
                         procName
                         lessThanOrEqualSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    Grt   lExpr rExpr -> checkCompareExpression
                         procName
                         greaterThanSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    GrtEq lExpr rExpr -> checkCompareExpression
                         procName
                         greaterThanOrEqualSymbol
                         lExpr
                         rExpr
                         paramMap
                         varMap
    UnaryMinus  expr  -> checkUnaryMinus procName expr paramMap varMap
    UnaryNot    expr  -> checkUnaryNot   procName expr paramMap varMap

-------------------------------------------------------------------------------
-- Check if expression is logic expression, if so, check if the expression type
-- is BoolType, and return the expression type if so, otherwise exit the
-- program with logic expression type error.
-------------------------------------------------------------------------------
checkLogicExpression ::
  Identifier -> String -> Expression -> Expression -> ParameterMap ->
  VariableMap -> Either (IO Task) ExpressionTable
checkLogicExpression procName operator lExpr rExpr paramMap varMap = do
  -- check the left expression first.
  let eitherLeftExprTable = checkLogicSubExpression
                            procName
                            operator
                            lExpr
                            paramMap
                            varMap
  case eitherLeftExprTable of
    Left err -> Left err
    Right lExprTable -> do
      -- check the right expression if the left expression is correct.
      let eitherRightExprTable = checkLogicSubExpression
                                 procName
                                 operator
                                 rExpr
                                 paramMap
                                 varMap
      case eitherRightExprTable of
        Left err -> Left err
        Right rExprTable -> do
          case operator of
            "||" -> Right $ OrTable lExprTable rExprTable BoolType
            "&&" -> Right $ AndTable lExprTable rExprTable BoolType

-------------------------------------------------------------------------------
-- Check if expression is logic expression, if so, check if the expression type
-- is BoolType, and return the expression type if so, otherwise exit the
-- program with logic expression type error.
-------------------------------------------------------------------------------
checkLogicSubExpression ::
  Identifier -> String -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkLogicSubExpression procName operator expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right exprTable -> do
      let errorExit = exitWithLogicExprTypeError procName operator
          isExpressionBoolTyped = expressionIsBoolTyped exprTable errorExit
      case exprTable of
        VariableTable _ _ -> isExpressionBoolTyped
        BoolTable  _      -> Right exprTable
        OrTable    _ _ _  -> isExpressionBoolTyped
        AndTable   _ _ _  -> isExpressionBoolTyped
        EqTable    _ _ _  -> isExpressionBoolTyped
        NotEqTable _ _ _  -> isExpressionBoolTyped
        LesTable   _ _ _  -> isExpressionBoolTyped
        LesEqTable _ _ _  -> isExpressionBoolTyped
        GrtTable   _ _ _  -> isExpressionBoolTyped
        GrtEqTable _ _ _  -> isExpressionBoolTyped
        NotTable   _ _    -> isExpressionBoolTyped
        otherwise         -> Left errorExit

-------------------------------------------------------------------------------
-- Check if expression is unary not, if so, return the expression table,
-- otherwise exit the program.
-------------------------------------------------------------------------------
checkUnaryNot ::
  Identifier -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkUnaryNot procName expr paramMap varMap = do
  let eitherUnaryNotExpression = checkLogicSubExpression
                                 procName
                                 unaryNotSymbol
                                 expr
                                 paramMap
                                 varMap
  case eitherUnaryNotExpression of
    Left err                 -> Left err
    Right unaryNotExpression -> Right (NotTable unaryNotExpression BoolType)

-------------------------------------------------------------------------------
-- Check if expression is comparison, if so, return the expression table,
-- otherwise exit the program.
-------------------------------------------------------------------------------
checkCompareExpression ::
  Identifier -> String -> Expression -> Expression -> ParameterMap ->
  VariableMap -> Either (IO Task) ExpressionTable
checkCompareExpression procName operator lExpr rExpr paramMap varMap = do
  -- check left expression first.
  let lExprTableEither = checkCompareSubExpression
                         procName
                         operator
                         lExpr
                         paramMap
                         varMap
  case lExprTableEither of
    Left err -> Left err
    Right lExprTable -> do
      -- if left expression is right, proceed to the right expression.
      let eitherRightExprTable = checkCompareSubExpression
                                 procName
                                 operator
                                 rExpr
                                 paramMap
                                 varMap
      case eitherRightExprTable of
        Left err -> Left err
        Right rExprTable -> do
          let equationExpression = checkIfExpressionsAreSameType
                                   procName
                                   operator
                                   lExprTable
                                   rExprTable
              comparisonExpression = getComparisonExpressionType
                                     procName
                                     operator
                                     lExprTable
                                     rExprTable
          case operator of
            "="  -> equationExpression
            "!=" -> equationExpression
            "<"  -> comparisonExpression
            "<=" -> comparisonExpression
            ">"  -> comparisonExpression
            ">=" -> comparisonExpression

-------------------------------------------------------------------------------
-- Check if the expression provided is string table or error, if so, exit with
-- comparison type error or with the specified error type, otherwise return the
-- expression table.
-------------------------------------------------------------------------------
checkCompareSubExpression ::
  Identifier -> String -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkCompareSubExpression procName operator expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right exprTable -> do
      case exprTable of
        StringTable _ -> Left $ exitWithComparisonTypeError procName operator
        otherwise     -> Right exprTable

-------------------------------------------------------------------------------
-- Check if expression given is a unary expression, if so, return the
-- expression table, otherwise exit the program.
-------------------------------------------------------------------------------
checkUnaryMinus ::
  Identifier -> Expression -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkUnaryMinus procName expr paramMap varMap = do
  let eitherExprTable = checkExpression procName expr paramMap varMap
  case eitherExprTable of
    Left err -> Left err
    Right exprTable -> do
      let exprTypeEither = checkUnaryMinusType procName exprTable
      case exprTypeEither of
        Left err       -> Left err
        Right exprType -> Right $ NegativeTable exprTable exprType

-------------------------------------------------------------------------------
-- Check if the expression is BoolType, if so, return the expression type,
-- otherwise exit the program with provided error method.
-------------------------------------------------------------------------------
checkUnaryMinusType ::
  Identifier -> ExpressionTable -> Either (IO Task) BaseType
checkUnaryMinusType procName exprTable = do
  let errorExit = exitWithUnaryMinusError procName
  case exprTable of
    VariableTable _   exprType -> expressionTypeIsNotBool exprType errorExit
    IntTable      _            -> Right IntType
    FloatTable    _            -> Right FloatType
    AddTable      _ _ exprType -> expressionTypeIsNotBool exprType errorExit
    SubTable      _ _ exprType -> expressionTypeIsNotBool exprType errorExit
    MulTable      _ _ exprType -> expressionTypeIsNotBool exprType errorExit
    DivTable      _ _ exprType -> expressionTypeIsNotBool exprType errorExit
    NegativeTable _   exprType -> expressionTypeIsNotBool exprType errorExit
    otherwise                  -> Left errorExit

-------------------------------------------------------------------------------
-- Check if the expression type is BoolType, if so, return the expression type,
-- otherwise exit the program with provided error method.
-------------------------------------------------------------------------------
expressionIsBoolTyped ::
  ExpressionTable -> IO Task -> Either (IO Task) ExpressionTable
expressionIsBoolTyped exprTable errorExit = do
  let exprType = getExpressionBaseType exprTable
  case exprType of
    BoolType  -> Right exprTable
    otherwise -> Left errorExit

-------------------------------------------------------------------------------
-- Check if the expression type is BoolType, if so, exit the program with
-- error, otherwise return the expression type.
-------------------------------------------------------------------------------
expressionTypeIsNotBool :: BaseType -> IO Task -> Either (IO Task) BaseType
expressionTypeIsNotBool exprType errorExit =
  case exprType of
    BoolType  -> Left errorExit
    otherwise -> Right exprType

-------------------------------------------------------------------------------
-- Note: Please filter the StringTable before using this function
--       Cannot be used for String
-- Check whether the type of given ExpressionTables are the same
-------------------------------------------------------------------------------
checkIfExpressionsAreSameType ::
  Identifier -> String -> ExpressionTable -> ExpressionTable ->
  Either (IO Task) ExpressionTable
checkIfExpressionsAreSameType procName operator lExpr rExpr = do
  let lType = getExpressionTableBaseType lExpr
      rType = getExpressionTableBaseType rExpr
  if lType == rType
    then Right (getComparisonTable operator lExpr rExpr lType)
    else Left (exitWithNotSameTypeError procName operator)


-------------------------------------------------------------------------------
-- Depending on the operator given, return different expression table, which
-- contains the left and right expression provided.
-------------------------------------------------------------------------------
getComparisonExpressionType ::
  Identifier -> String -> ExpressionTable -> ExpressionTable ->
  Either (IO Task) ExpressionTable
getComparisonExpressionType procName operator lExpr rExpr = do
  let lType = getExpressionTableBaseType lExpr
      rType = getExpressionTableBaseType rExpr
  if lType /= rType then do
    let eitherxprType = getExpressionTableType procName lExpr rExpr
    case eitherxprType of
      Left err -> Left err
      Right exprType ->
        Right (getComparisonTable operator lExpr rExpr exprType)

  else Right (getComparisonTable operator lExpr rExpr lType)

-------------------------------------------------------------------------------
-- Depending on the operator given, return different expression table, which
-- contains the left and right expression provided.
-------------------------------------------------------------------------------
getComparisonTable ::
  String -> ExpressionTable -> ExpressionTable -> BaseType -> ExpressionTable
getComparisonTable operator lExpr rExpr baseType
  | operator == equalSymbol = EqTable lExpr rExpr baseType
  | operator == notEqualSymbol = NotEqTable lExpr rExpr baseType
  | operator == lessThanSymbol = LesTable lExpr rExpr baseType
  | operator == lessThanOrEqualSymbol = LesEqTable lExpr rExpr baseType
  | operator == greaterThanSymbol = GrtTable lExpr rExpr baseType
  | operator == greaterThanOrEqualSymbol = GrtEqTable lExpr rExpr baseType

-------------------------------------------------------------------------------
-- Check if the provided variable's type matches the assign expression type,
-- or if the variable is float and expression is int, if so, return the assign
-- statement table, otherwise exit the program with assign type error.
-------------------------------------------------------------------------------
checkAssignType ::
  Identifier -> ExpressionTable -> ExpressionTable -> BaseType ->
  Either (IO Task) StatementTable
checkAssignType procName variableTable expressionTable exprType = do
  let varType      = variableType variableTable
      variableName = varName $ variable variableTable
  if varType == exprType
  then Right $ AssignTable variableTable expressionTable
  else if (FloatType == varType) && (IntType == exprType)
       then Right $ AssignTable variableTable expressionTable
       else Left $ exitWithAssignTypeError procName variableName

-------------------------------------------------------------------------------
-- Check if the provided variable is in the parameter map or the variable map,
-- if so, check the indicator and return the expression table, otherwise exit
-- the program with undefined variable error.
-------------------------------------------------------------------------------
checkVariable ::
  Identifier -> Variable -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkVariable procName var paramMap varMap = do
  let id = varId var
      paramBaseType = lookupBaseTypeParamMap id paramMap
  case (M.member id paramMap) of
    True  -> checkParamIndicator procName var paramBaseType
    False -> do
      let varDecl     = varMap M.! id
          varBaseType = lookupBaseTypeVarMap id varMap
      case (M.member id varMap) of
          True  -> checkVariableIndicator
                   procName
                   var
                   varDecl
                   varBaseType
                   paramMap
                   varMap
          False -> Left $ exitWithUndefinedVariable id

-------------------------------------------------------------------------------
-- Check if the provided variable is an array or matrix, if so, exit with the
-- variable indicator error, otherwise return the variable's expression table.
-------------------------------------------------------------------------------
checkParamIndicator ::
  Identifier -> Variable -> BaseType -> Either (IO Task) ExpressionTable
checkParamIndicator procName var paramBaseType = do
  let id = varId var
      varIndicator = varShapeIndicator var
      varSubTable  = VariableSubTable id NoIndicatorTable
  case varIndicator of
    NoIndicator -> Right $ VariableTable varSubTable paramBaseType
    otherwise   -> Left  $ exitWithVarIndicatorError procName id

-------------------------------------------------------------------------------
-- Check if the provided variable's shape indicator matches the provided
-- variable declaration shape indicator, if so, return the expression table,
-- otherwise exit the program with array matrix dimension typed error.
-------------------------------------------------------------------------------
checkVariableIndicator ::
  Identifier -> Variable -> VariableDeclaration -> BaseType -> ParameterMap ->
  VariableMap -> Either (IO Task) ExpressionTable
checkVariableIndicator procName var varDecl varBaseType paramMap varMap = do
  let id = varId var
      varIndicator  = varShapeIndicator var
      declarationVarIndicator = varShapeIndicator $ declarationVariable varDecl
      varSubTable   = VariableSubTable id NoIndicatorTable
  case (varIndicator, declarationVarIndicator)of
    (NoIndicator, NoIndicator) -> Right $ VariableTable varSubTable varBaseType
    (Array  n   , Array  _   ) -> checkArrayDimension
                                  procName
                                  n
                                  var
                                  varBaseType
                                  paramMap
                                  varMap
    (Matrix m n , Matrix _ _ ) -> checkMatrixDimensions
                                  procName
                                  (m, n)
                                  var
                                  varBaseType
                                  paramMap
                                  varMap
    otherwise -> Left  $ exitWithVarIndicatorNotSame procName id

-------------------------------------------------------------------------------
-- Check if the provided expression for array is IntType, if so, return the
-- expression table, otherwise exit the program with array matrix dimension
-- typed error.
-------------------------------------------------------------------------------
checkArrayDimension ::
  Identifier -> Expression -> Variable -> BaseType -> ParameterMap ->
  VariableMap -> Either (IO Task) ExpressionTable
checkArrayDimension procName expr var varBaseType paramMap varMap = do
  let varName = varId var
      eitherExpressionTable = checkDimension
                              procName
                              expr
                              varName
                              paramMap
                              varMap
  case eitherExpressionTable of
    Left  err             -> Left err
    Right expressionTable -> do
        let arrayTable = ArrayTable expressionTable
            varSubTable = VariableSubTable varName arrayTable
        Right $ VariableTable varSubTable varBaseType

-------------------------------------------------------------------------------
-- Check if the provided expressions are IntType, if so, return the expression
-- table, otherwise exit the program with array matrix dimension typed error.
-------------------------------------------------------------------------------
checkMatrixDimensions ::
  Identifier -> (Expression, Expression) -> Variable -> BaseType ->
  ParameterMap -> VariableMap -> Either (IO Task) ExpressionTable
checkMatrixDimensions procName (exprM, exprN) var varBaseType paramMap varMap = do
  -- check expression m first.
  let varName = varId var
      eitherExpressionTableM = checkDimension
                               procName
                               exprM
                               varName
                               paramMap
                               varMap
  case eitherExpressionTableM of
    Left  err             -> Left err
    Right expressionTableM -> do
      -- if express m passed, check expression n.
      let eitherExpressionTableN = checkDimension
                                   procName
                                   exprN
                                   varName
                                   paramMap
                                   varMap
      case eitherExpressionTableN of
        Left  err             -> Left err
        Right expressionTableN -> do
          let matrixTable = MatrixTable expressionTableM expressionTableN
              varSubTable = VariableSubTable varName matrixTable
          Right $ VariableTable varSubTable varBaseType

-------------------------------------------------------------------------------
-- Check if the given expression is IntType, if so, return the expression
-- table, otherwise exit the program with array matrix dimension typed error.
-------------------------------------------------------------------------------
checkDimension ::
  Identifier -> Expression -> String -> ParameterMap -> VariableMap ->
  Either (IO Task) ExpressionTable
checkDimension procName expr varName paramMap varMap = do
  let eitherExpressionTable = checkExpression procName expr paramMap varMap
  case eitherExpressionTable of
    Left  err             -> Left err
    Right expressionTable -> do
      let exprType = getExpressionBaseType expressionTable
      case exprType of
        IntType   -> Right expressionTable
        otherwise -> Left $ exitArrayMatrixDimensionTypeError procName varName

-------------------------------------------------------------------------------
-- Given the operator, left and right expression tables, and the base type,
-- return the expression table for the arthmetic operation.
-------------------------------------------------------------------------------
checkArthmeticOperation ::
  Identifier -> String -> Expression -> Expression -> ParameterMap ->
  VariableMap -> Either (IO Task) ExpressionTable
checkArthmeticOperation procName operator lExpr rExpr paramMap varMap = do
  let eitherLeftExprTable = checkExpression procName lExpr paramMap varMap
  case eitherLeftExprTable of
    Left err -> Left err
    Right leftExprTable -> do
      let eitherRightExprTable = checkExpression procName rExpr paramMap varMap
      case eitherRightExprTable of
        Left err -> Left err
        Right rightExprTable -> do
          let eitherBaseType = getExpressionTableType
                               procName
                               leftExprTable
                               rightExprTable
          case eitherBaseType of
            Left err -> Left err
            Right baseType -> Right $ insertExpressionTableByOperator
                                      operator
                                      leftExprTable
                                      rightExprTable
                                      baseType

-------------------------------------------------------------------------------
-- Given the operator, left and right expression tables, and the base type,
-- return the expression table.
-------------------------------------------------------------------------------
insertExpressionTableByOperator ::
  String -> ExpressionTable -> ExpressionTable -> BaseType -> ExpressionTable
insertExpressionTableByOperator operator lExprTable rExprTable baseType
  | operator == addSymbol   = AddTable lExprTable rExprTable baseType
  | operator == minusSymbol = SubTable lExprTable rExprTable baseType
  | operator == timesSymbol = MulTable lExprTable rExprTable baseType
  | operator == divSymbol   = DivTable lExprTable rExprTable baseType

-------------------------------------------------------------------------------
-- Insert statements tables into provided procedure' existing procedure table,
-- and return the new procedure table containing statements.
-------------------------------------------------------------------------------
insertStatementsIntoProcedureTable ::
  Procedure -> ProgramMap -> Either (IO Task) ProcedureTable
insertStatementsIntoProcedureTable procedure procMap =  do
  let eitherStatements = insertStatementList
                         procedureName
                         (bodyStatements $ body procedure)
                         paramMap
                         varMap
                         procMap
      procedureName = getProcedureIdentifier procedure
      procedureTable = procMap M.! procedureName
      paramMap = parameterMap procedureTable
      varMap = variableMap procedureTable
  case eitherStatements of
    Left err         -> Left err
    Right statements -> Right $ ProcedureTable paramMap varMap statements

-------------------------------------------------------------------------------
-- Insert statements tables into provided procedures' existing procedure
-- tables, and return the new procedure table containing statements.
-------------------------------------------------------------------------------
insertStatementsInProcList ::
  [Procedure] -> ProgramMap -> Either (IO Task) ProgramMap
insertStatementsInProcList (proc:[]) procMap = do
  let eitherProcedureTable = insertStatementsIntoProcedureTable proc procMap
      procName = getProcedureIdentifier proc
  case eitherProcedureTable of
    Left err             -> Left err
    Right procedureTable -> Right $ M.insert procName procedureTable procMap
insertStatementsInProcList (proc:procs) procMap = do
  let eitherProcedureTable = insertStatementsIntoProcedureTable proc procMap
      procName = getProcedureIdentifier proc
  case eitherProcedureTable of
    Left err -> Left err
    Right procedureTable -> do
      let eitherNewProcMap = insertStatementsInProcList procs procMap
      case eitherNewProcMap of
        Left err -> Left err
        Right newProcMap -> Right $ M.insert procName procedureTable newProcMap

-------------------------------------------------------------------------------
-- Analyze the given parameter list, insert them into a new parameter table and
-- return it.
-------------------------------------------------------------------------------
insertParameterMap ::
  Identifier -> [Parameter] -> Int -> ParameterMap ->
  Either (IO Task) ParameterMap
insertParameterMap _ [] _ paramMap = Right paramMap
insertParameterMap _ (param:[]) index paramMap =
  Right $ M.insert (passingIdent param) (index, param) paramMap
insertParameterMap procName (param:params) index paramMap = do
  let eitherParamMap = insertParameterMap procName params (index+1) paramMap
  case eitherParamMap of
    Left err -> Left err
    Right newParamMap -> do
      let paramName = (passingIdent param)
      case (M.member paramName newParamMap) of
        True  -> Left $ exitWithMultipleVarDeclaration paramName procName
        False -> Right $ M.insert paramName (index, param) newParamMap

-------------------------------------------------------------------------------
-- Analyze the given procedure, get the parameter and variable tables, and
-- insert them into a new procedure table, otherwise return error.
-------------------------------------------------------------------------------
insertProcedureTableWithoutStatements ::
  Procedure -> Either (IO Task) ProcedureTable
insertProcedureTableWithoutStatements procedure = do
  let  eitherParamMap = insertParameterMap
                        procedureName
                        (getProcedureParameters procedure)
                        0
                        M.empty
       procedureName = getProcedureIdentifier procedure
  case eitherParamMap of
    Left err -> Left err
    Right paramMap -> do
      let eitherVarMap = insertVariableMap
                         procedureName
                         (bodyVarDeclarations $ body procedure)
                         paramMap
                         M.empty
      case eitherVarMap of
        Left err     -> Left err
        Right varMap -> Right $ ProcedureTable paramMap varMap []

-------------------------------------------------------------------------------
-- Get the procedure table which does not contain procedure statements, and
-- insert it into the map storing program table, and return a new copy of the
-- map.
-------------------------------------------------------------------------------
insertProcWithoutStatements ::
  Procedure -> ProgramMap -> Either (IO Task) ProgramMap
insertProcWithoutStatements procedure procMap = do
  let eitherProcTable = insertProcedureTableWithoutStatements procedure
      procName = getProcedureIdentifier procedure
  case eitherProcTable of
    Left err        -> Left err
    Right procTable -> Right $ M.insert procName procTable procMap

-------------------------------------------------------------------------------
-- Get the procedure tables for provided procedure list, insert them into the
-- map provided, and return a new copy of the new map containing all
-- information.
-------------------------------------------------------------------------------
insertProcListWithoutStatements ::
  [Procedure] -> ProgramMap -> Either (IO Task) ProgramMap
insertProcListWithoutStatements (proc:[]) procMap =
  insertProcWithoutStatements proc procMap
insertProcListWithoutStatements (proc:procs) procMap = do
  let newProcMap = insertProcListWithoutStatements procs procMap
  case newProcMap of
    Left err -> Left err
    Right subProcMap -> do
      let procName = getProcedureIdentifier proc
      case (M.member procName subProcMap) of
        True  -> Left $ exitWithDuplicateProcedure procName
        False -> insertProcWithoutStatements proc subProcMap

-------------------------------------------------------------------------------
-- analyze procedure list.
-------------------------------------------------------------------------------
analyze :: [Procedure] -> Either (IO Task) ProgramMap
analyze procedures = do
  let eitherProgramMap = insertProcListWithoutStatements procedures M.empty
  case eitherProgramMap of
      Left err         -> Left err
      Right programMap -> insertStatementsInProcList procedures programMap

-------------------------------------------------------------------------------
-- Main entry of semantic Analyze module.
-------------------------------------------------------------------------------
semanticAnalyse :: GoatProgram -> Either (IO Task) ProgramMap
semanticAnalyse program = analyze $ procedures program
